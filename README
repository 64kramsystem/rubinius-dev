WHAT IS RUBINIUS

Rubinius is a next-generation virtual machine and compiler for Ruby.
Based loosely on the Smalltalk-80 'Blue Book' design, Rubinius will provide
a rich, high-performance environment for running Ruby code.

COMPILING RUBINIUS

Currently Rubinius can be built on UNIX-like systems, such as Linux and MacOS.
It requires gcc 4.x and glib2, though these dependencies are temporary.
Additionally, you will need an installation of ruby 1.8.x, and the following
as gems or libraries:
  * rake
  * rspec (if you want to run specs, currently works with 0.7.5)
??: * ruby2ruby (also used in specs)

Once these are installed, type: 'rake build:all' to compile Rubinius. 
This builds the current version of Rubinius, known as 'shotgun'.
Use 'rake test' to run the tests.

RUNNING RUBINIUS

After running 'rake build:all', there will be a 'rubinius' binary in
the 'shotgun' directory. This binary currently does not mimic the usual 'ruby'
command-line args. To run a Ruby script, type:
./shotgun/rubinius some_ruby_file.rb
The command first compiles the script to an 'rbc' file, then uses Rubinius to execute it.

BOOTSTRAPPING/DEVELOPING RUBINIUS

Requires:
  * ParseTree [?]
  * sydparse (the version included, use 'rake build:syd' to obtain the gem)
  * zip (provided on pretty much all unix platforms these days)

Use the local sydparse by building locally using the 'rake build:syd' command. 
The bootstrapping tasks will fail until you install the correct version of sydparse.

Bootstrapping uses a command aptly called bin/obsolete.rcompile
(obsolete because it makes use of the fragile sydparse).

rake build:bootstrap build:core build:compiler
rebuilds the three .rba files in runtime/ -- you don't need to do this
until you start hacking the Ruby files in lib and kernel.

rake build:dev is a shortcut for rebuilding shotgun, core and compiler
(but not bootstrap as this is touched less often) if you are
developing things.

OBSOLETE STUFF

Don't touch:
./bin/shotgun
(list to be completed)
[evan: can we delete the cruft, please?]

STATUS

Rubinius is under heavy development, and currently supports the basic Ruby 
classes and kernel methods. The codebase is written in a mixture of 
ANSI C and Ruby; with more Ruby and less C as the project proceeds.
You should not run your mission-critical Rails apps under Rubinius yet.

GOALS

* Thread safety. Rubinius intends to be thread-safe and embeddable.
  It does not currently meet this goal due to some components borrowed from
  the mainline Ruby interpreter.

* Clean, readable code that is easy for users to understand and extend.

* Reliable, rock-solid code.  Valgrind is used to help verify correctness.

* Bring modern techiques to the Ruby runtime. Pluggable garbage collectors and
  code optimizers are possible examples.

VOLUNTEERING TO HELP

The Rubinius team welcomes contributions, bug reports, test cases, and monetary support.
One possible way to help is:
1. Add a test for a Ruby core method.
2. Go to the appropriately-named file in the 'kernel' directory.
3. Implement that method in Ruby.
4. Type 'rake build:kernel' to make your change take effect.
5. Run the tests until they pass. :)
6. Create a patch with 'svn diff' and send it to the mailing list.
The 'ri' command is a rich source of examples and test cases.

STRUCTURE

Rubinius currently uses C to bootstrap the system.
In the future, a limited dialect of Ruby called 'cuby' will be used to generate C.
This is a time-honored technique, used by systems such as Squeak, Smalltalk, and 
Algol on the Burroughs systems (as seen in the movie 'Tron').

For now, this code is hand-written, and can be found in the ./shotgun/lib directory.
This code was ported from a Ruby implementation found in the ./lib directory.
For example, shotgun/lib/object_memory.c is the C translation of lib/object_memory.rb.

The compiler, assembler, and bytecode generators are all written in Ruby, and can
be found under the ./lib directory.  Other systems use the word 'translator' for what
is here referred to as 'compiler'.  The ./bin/rcc script can be used to display the
symbolic output of the compiler, for debugging or learning purposes.
