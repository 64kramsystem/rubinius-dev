$verbose = Rake.application.options.trace

def x(cmd)
  sh cmd, :verbose => $verbose
end

class CCompile
  def initialize
    @includes = []
    @flags = []
    @linker = "gcc"
    @deps = {}
  end

  attr_accessor :includes, :flags, :deps

  def cpp!
    @linker = "g++"
  end

  def compile(input, output=nil)
    output = input.gsub(/\.[^\.]+$/, ".o") unless output

    includes = @includes.map { |i| "-I#{i}" }.join(" ")
    flags =    @flags.join(" ")
    od = File.dirname(output)
    Dir.mkdir od unless File.directory? od

    puts "CC #{input}"
    x "#{compiler(input)} #{includes} #{flags} -c -o #{output} #{input} 2>&1"
  end

  def compiler(file)
    if File.basename(file) == "c"
      "gcc"
    else
      "g++"
    end
  end

  def <<(pattern)
    list = FileList[pattern]
    objects = []

    list.each do |name|
      headers = extract_headers(name)

      output = name.gsub(/\.[^.]+$/, ".o")
      objects << output

      file output => [name] + headers do
        compile(name, output)
      end
    end

    return objects
  end

  def extract_headers(path)
    dir = File.dirname(path)
    h = File.read(path).scan(/#include\s*.([^\n]*)./).map do |i|
      File.join(dir, i[0])
    end

    deps = h.find_all do |name|
      File.exists?(name) and /\.h(?:pp)?/.match(name)
    end

    subdeps = []

    @deps[path] = deps

    # Process the headers themselves now.
    deps.each do |dep|
      if @deps[dep]
        subdeps += @deps[dep]
        next
      end

      @deps[dep] = true # place holder, to prevent unchecked recursion.
      subdeps += extract_headers(dep)
    end

    @deps[path] = deps
    return deps
  end

  def link(name, opts)
    x "#{@linker} -o #{name} #{opts[:objects].join(' ')} #{opts[:libs].join(' ')}"
  end

end

compiler = CCompile.new

rule ".h"
rule ".hpp"

ex_libs = %w!
  ../external_libs/libtommath/libtommath.a
  ../external_libs/onig/.libs/libonig.a
	../external_libs/libffi/.libs/libffi.a
	../external_libs/libltdl/.libs/libltdl.a
	../external_libs/libev/.libs/libev.a
  -ldl!

ex_libs << "-lrt" if RUBY_PLATFORM =~ /linux/

ex_inc  = %w!
  ../external_libs/libtommath
  ../external_libs/onig
  ../external_libs/libffi/include
  ../external_libs/libltdl
  ../external_libs/libev!

tests = FileList["test_*.hpp"]

compiler.cpp!

compiler.includes += ex_inc
compiler.includes << "cxxtest"
compiler.includes << ".."

compiler.flags << "-Wall" << "-Wno-write-strings" << "-Wno-sign-compare" << "-ggdb"

objs = compiler << "../*.cpp"
objs += compiler << "../*.c"

file "../gen/task_instructions_switch.c" => "../instructions.rb" do
  puts "GEN instructions.rb"
  x "cd ..; ruby instructions.rb"
end

file "../builtin_task.o" => "../gen/task_instructions_switch.c"

file "runner.cpp" => tests + objs do
  puts "GEN runner.cpp"
	x "cxxtest/cxxtestgen.pl --error-printer --have-eh --abort-on-fail -o runner.cpp #{tests}"
end

file "runner.o" => "runner.cpp" do
  compiler.compile "runner.cpp"
end

file "runner" => "runner.o" do
  compiler.link "runner", :objects => objs + ["runner.o"], :libs => ex_libs
end

task :test => "runner" do
  x "./runner"
end

simple = objs + (compiler << "simple.cpp")

task :simple => simple do
  compiler.link "simple", :objects => simple, :libs => ex_libs
end

task :default => :test

task :clean do
  x "rm -rf *.gcda *.gcno *.gcov *.dSYM *.o ../*.o runner coverage"
end
