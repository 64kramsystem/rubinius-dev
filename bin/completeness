#!/usr/bin/env ruby
#
# Generate a completeness report from MRI classes and modules
# based on the specs.

require 'optparse'

module Completeness
  VERSION = '0.0.1'
end

get_class_or_module = lambda do |const|
  constant = const.split('::').inject(nil) { |c,s| c ? c.const_get(s) : Object.const_get(s) }
  return constant if (constant.is_a?(Module) or constant.is_a?(Class)) and
    not ['OptionParser', 'SystemExit'].include?(constant.name)
end

target = 'shotgun/rubinius'
constants = []
except = []
requires = []
constant_names = []
report_failures = false
quiet = false

opts = OptionParser.new("", 24, '   ') do |opts|
  opts.banner = "completeness [options]"
  opts.separator ""

  opts.on("-r", "--require LIBRARY", String, "Name of library to require") do |f|
    requires << f
  end
  opts.on("-c", "--constant CONSTANT", String,
          "Name of a Class or Module") do |c|
    constant_names << c
  end
  opts.on("-t", "--target TARGET", String,
          "Implementation to test for completeness: r:ruby|r19:ruby19|x:rbx|j:jruby") do |t|
    case t
    when 'r', 'ruby'
      target = 'ruby'
    when 'r19', 'ruby19'
      target = 'ruby19'
    when 'x', 'rbx', 'rubinius'
      target = 'shotgun/rubinius'
    when 'j', 'jruby'
      target = 'jruby'
    else
      target = t
    end
  end
  opts.on("-x", "--exclude STRING|FILE", String,
          "Exclude example(s) with descriptions matching STRING or each line of FILE") do |r|
    except << r
  end
  opts.on("-v", "--version", "Show version") do
    puts "Completeness Reporter #{Completeness::VERSION}"
    exit
  end
  opts.on("-F", "--report-failures", "Report spec failure locations") do
    report_failures = true
  end
  opts.on("-q", "--quiet", "Suppress output except for final summary") do
    quiet = true
  end
  opts.on("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.parse ARGV
end

requires.each { |r| require r }
cmd = %(bin/mspec -t #{target} #{requires.map { |r| "-r#{r}" }.join(" ")} -e '%s ' #{except.map { |x| "-x #{x}" }.join(' ')} -f d spec 2> /dev/null)

print_summary = lambda do |str, name, tab|
  examples, failures = 0, 0
  failure_messages = []
  str.scan(/(\d+) examples, (\d+) failures/) do |e, f|
    examples += e.to_i
    failures += f.to_i
  end
  str.scan(/\n(\d+\)\n)(([^\n]+\n)+)/) do |number, error|
    failure_messages << error
  end
  summary = if examples > 0
    "#{examples} examples, #{failures} failures"
  else
    "No examples found"
  end
  puts "#{name}\n    #{summary}" unless quiet
  tab.add(examples, failures, failure_messages)
end

constants = constant_names.map { |c| get_class_or_module.call(c) }
if constants.empty?
  constants = Object.constants.map { |c| get_class_or_module.call(c) }
end

class Tabulator
  def initialize
    @methods = @examples = @failures = @missing = 0
    @failure_messages = []
    @start = Time.now
  end

  def add(examples, failures, failure_messages = [])
    @methods += 1
    @examples += examples
    @failures += failures
    @failure_messages.push *failure_messages
    @missing += 1 if examples == 0
  end

  def summarize(list_failures=false)
    puts "\nFinished in #{Time.now - @start} seconds\n\n"
    puts "#{@methods} methods, #{@examples} examples, #{@failures} failures, #{@missing} methods with no examples"
    if list_failures && @failure_messages.size > 0
      puts "\nFailed specs:\n\n"
      @failure_messages.each_with_index do |message, number|
        puts "#{number+1})\n#{message}\n\n"
      end
    end
  end

end

tabulator = Tabulator.new

constants.compact.each do |c|
  (c.methods(false) + c.singleton_methods).uniq.sort.each do |m|
    name = "#{c}.#{m}"
    print_summary.call(%x(#{cmd % name}), name, tabulator)
  end

  (c.public_instance_methods(false) +
      c.private_instance_methods(false) +
      c.protected_instance_methods(false)).sort.each do |m|
    name = "#{c}\##{m}"
    print_summary.call(%x(#{cmd % name}), name, tabulator)
  end
end

tabulator.summarize(!quiet && report_failures)
