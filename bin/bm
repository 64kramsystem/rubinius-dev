#!/usr/bin/env ruby

# Must use our benchmark.rb, which has patches -vs- Ruby distribution
require File.expand_path(File.join(File.dirname(__FILE__),'../stdlib/benchmark'))
include Benchmark

require 'optparse'
require 'ostruct'

BM_GLOB        = 'test/benchmark/*/bm*.rb'
INTERPRETERS   = ['ruby','shotgun/rubinius']
WIDTH          = 40
REPORT_WIDTH   = WIDTH - 6
COLUMN_WIDTH   = 16
DECIMAL_FORMAT = '%4.4f'

OPTIONS = OpenStruct.new( :width => 1024, :report => true )

options = OptionParser.new do |opts|
  opts.on('-c', '--chart [FILENAME]') do |c|
    OPTIONS.chart = c || 'times.svg'
  end

  opts.on('-d', '--diff-chart [FILENAME]') do |d|
    OPTIONS.diffchart = d || 'difference.svg'
  end

  opts.on('-w', '--width WIDTH') do |w|
    OPTIONS.chart = w
  end

  opts.on('-g', '--grep REGEX') do |g|
    OPTIONS.grep = g
  end

  opts.on('-n', '--ngrep REGEX') do |n|
    OPTIONS.ngrep = n
  end

  opts.on('-h', '--help') do |h|
    OPTIONS.help = h
  end

  opts.on('--no-report') do |r|
    OPTIONS.report = r
  end

  opts.on('-w', '--warmup') do |w|
    OPTIONS.warmup = w
  end
end

options.parse!

if OPTIONS.help then
  puts options.summarize
  exit
end

class RbxBenchmarkFile
  def initialize(interpreter,file)
    @interpreter = interpreter
    @file        = file
  end

  def pretty_interpreter
    @interpreter.match(%r{ruby|rubinius})[0]
  end

  def pretty_file
    @file.match(%r{[^/]+/[^/]+$})[0]
  end

  def label
    pretty_interpreter + ': ' + pretty_file
  end

  def command
    command = "#{@interpreter} #{@file}"

    case @file
      when /wycats\/bm_string[.]rb/
        command << %{ -x "String#unpack"}
      when /borasky\/bm_MatrixBenchmark[.]rb/
        command << %{ 64}
    end

    command
  end

  def quiet_command
    command + ' > /dev/null 2>&1'
  end

  def run
    @result = if OPTIONS.warmup then
                Benchmark.bmbm do |x|
                  x.report(label + ' ' * (WIDTH - label.length)) do
                    if system quiet_command then
                      @pass = true
                    else
                      @pass = false
                      system command
                    end
                  end
                end.first
              else
                Benchmark.bm do |x|
                  x.report(label + ' ' * (WIDTH - label.length)) do
                    if system quiet_command then
                      @pass = true
                    else
                      @pass = false
                      system command
                    end
                  end
                end
              end
  end

  def passed?
    @pass
  end

  def failed?
    ! @pass
  end

  def time
    passed? ? @result.real : 0
  end

  def skip
    @skipped = true
  end

  def skipped?
    @skipped
  end

  def unchartable?
    failed? or skipped?
  end

  def report
    if skipped? then
      'Skipped'
    elsif passed? then
      DECIMAL_FORMAT % time
    else
      'Failed'
    end.rjust(COLUMN_WIDTH)
  end
end

class RbxBenchmarkRun
  attr_reader :interpreter
  attr_reader :results

  def initialize(interpreter)
    @interpreter = interpreter
    @results     = []
    @total       = Benchmark::Tms.new
  end

  def clean
    if @interpreter =~ /rubinius/ then
      Dir[BM_GLOB + 'c'].each do |file|
        File.unlink file
      end
    end
  end

  def run
    clean

    Dir[BM_GLOB].each do |file|
      @results << RbxBenchmarkFile.new(@interpreter,file)

      if OPTIONS.grep and ! file.match(OPTIONS.grep)
        @results.last.skip
        next
      end

      if OPTIONS.ngrep and file.match(OPTIONS.ngrep) then
        @results.last.skip
        next
      end

      @results.last.run
    end

    self
  end

  def time
    @results.inject(0) { |total, result| total + result.time }
  end

  def chart_points
    @results.collect do |result|
      if result.unchartable?
        nil
      else
        result.time
      end
    end
  end
end

def difference(ruby,rubinius)
  if ruby.unchartable? or rubinius.unchartable? then
    nil
  elsif ruby.time < rubinius.time then
    -rubinius.time / ruby.time
  else
    ruby.time / rubinius.time
  end
end

def report(runs)
  header = 'file'.ljust(REPORT_WIDTH)

  runs.each do |run|
    header << (run.results.first.pretty_interpreter).rjust(COLUMN_WIDTH)
  end

  header << 'difference'.rjust(COLUMN_WIDTH)

  puts
  puts header
  puts '-' * header.length

  0.upto(runs.first.results.length - 1) do |i|
    line = runs.first.results[i].pretty_file.ljust(REPORT_WIDTH)
    results = []
    runs.each do |run|
      results << run.results[i]
      line    << run.results[i].report
    end

    diff = difference(results.first,results.last)

    line << if diff.nil? then
              'n/a'
            else
              DECIMAL_FORMAT % diff
            end.rjust(COLUMN_WIDTH)

    puts line
  end
end

runs = []

INTERPRETERS.each do |i|
  runs << RbxBenchmarkRun.new(i).run
end

if OPTIONS.report then
  report(runs)
end

if OPTIONS.chart then
  require 'rubygems'
  require 'scruffy'

  chart_point_sets = runs.collect { |run| run.chart_points }

  deletes = []

  for i in 0..chart_point_sets.length-1
    delete = false
    for j in 0..chart_point_sets.first.length-1
      if chart_point_sets[i][j].nil? then
        deletes << j
      end
    end
  end

  chart_point_sets.each do |cps|
    deletes.uniq.sort.reverse.each { |d| cps.delete_at(d) }
  end

  graph = Scruffy::Graph.new

  runs.each do |run|
    graph << Scruffy::Layers::Line.new( :title  => run.interpreter,
                                        :points => chart_point_sets.shift )
  end

  # graph.point_markers = runs.first.results.reject do |result|
  #   result.unchartable?
  # end.collect do |result|
  #   result.pretty_file
  # end

  puts "Rendering chart to #{OPTIONS.chart}"

  graph.render( :width => OPTIONS.width, :to => OPTIONS.chart )
end

if OPTIONS.diffchart then
  require 'rubygems'
  require 'scruffy'

  differences = []
  
  0.upto(runs.first.results.length - 1) do |i|
    differences << difference(runs.first.results[i],runs.last.results[i])
  end
  
  differences.reject! { |d| d.nil? }

  graph = Scruffy::Graph.new

  graph << Scruffy::Layers::Line.new( :title  => 'Rubinius times faster, negative is times slower',
                                      :points => differences )

  # graph.point_markers = runs.first.results.reject do |result|
  #   result.unchartable?
  # end.collect do |result|
  #   result.pretty_file
  # end

  puts "Rendering diffchart to #{OPTIONS.diffchart}"

  graph.render( :width => OPTIONS.width, :to => OPTIONS.diffchart )
end
