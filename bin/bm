#!/usr/bin/env ruby

require 'benchmark'
include Benchmark

require 'optparse'
require 'ostruct'

BM_GLOB      = 'test/benchmark/*/bm*.rb'
INTERPRETERS = ['ruby','shotgun/rubinius']
WIDTH        = 50
COLUMN_WIDTH = 10

OPTIONS = OpenStruct.new( :width => 1024, :report => true )

options = OptionParser.new do |opts|
  opts.on('-c', '--chart [FILENAME]') { |c| OPTIONS.chart  = c || 'bm.svg' }
  opts.on('-w', '--width WIDTH')      { |w| OPTIONS.chart  = w }
  opts.on('-g', '--grep REGEX')       { |g| OPTIONS.grep   = g }
  opts.on('-n', '--ngrep REGEX')      { |n| OPTIONS.ngrep  = n }
  opts.on('-h', '--help')             { |h| OPTIONS.help   = h }
  opts.on('--no-report')              { |r| OPTIONS.report = r }
end

options.parse!

if OPTIONS.help then
  puts options.summarize
  exit
end

class RbxBenchmarkFile
  def initialize(interpreter,file)
    @interpreter = interpreter
    @file        = file

    run
  end

  def pretty_interpreter
    @interpreter.match(%r{ruby|rubinius})[0]
  end

  def pretty_file
    @file.match(%r{[^/]+/[^/]+$})[0]
  end

  def label
    pretty_interpreter + ': ' + pretty_file
  end

  def command
    command = "#{@interpreter} #{@file}"

    case @file
      when /wycats\/bm_string[.]rb/
        command += %{ -x "String#unpack"}
      when /borasky\/bm_MatrixBenchmark[.]rb/
        command += %{ 64}
    end

    command
  end

  def quiet_command
    command + ' > /dev/null 2>&1'
  end

  def run
    @result = Benchmark.bmbm do |x|
      x.report(label + ' ' * (WIDTH - label.length)) do
        if system quiet_command then
          @pass = true
        else
          @pass = false
          system command
        end
      end
    end.first
  end

  def pass?
    @pass
  end

  def time
    pass? ? @result.real : 0
  end
end

class RbxBenchmarkRun
  attr_reader :interpreter
  attr_reader :results

  def initialize(interpreter)
    @interpreter = interpreter
    @results     = []
    @total       = Benchmark::Tms.new
  end

  def clean
    if @interpreter =~ /rubinius/ then
      Dir[BM_GLOB + 'c'].each do |file|
        File.unlink file
      end
    end
  end

  def run
    clean

    Dir[BM_GLOB].each do |file|
      if OPTIONS.grep then
        next unless file.match(OPTIONS.grep)
      end

      if OPTIONS.ngrep then
        next if file.match(OPTIONS.ngrep)
      end

      @results << RbxBenchmarkFile.new(@interpreter,file)
    end

    self
  end

  def time
    @results.inject(0) {|total, result| total + result.time }
  end

  def line_chart
    Scruffy::Layers::Line.new( :title  => @interpreter,
                               :points => @results.collect do |result|
                                            result.time
                                          end )
  end
end

def report(results)
  results.each do |run|
    puts
    puts run.interpreter
    puts '-' * run.interpreter.length

    run.results.each do |result|
      if result.pass? then
        puts result.time
      else
        puts "Failed"
      end
    end

    puts 'Total time, not including failures: ' + run.time.to_s
    puts
  end
end

def scrub_failures(runs)
  runs.each do |run_1|
    results = run_1.results
    results.each_with_index do |result,i|
      unless result.pass?
        runs.each do |run_2|
          run_2.results.delete_at(i)
        end
        return true
      end
    end
  end
  false
end

runs = []

INTERPRETERS.each do |i|
  runs << RbxBenchmarkRun.new(i).run
end

if OPTIONS.report then
  report(runs)
end

if OPTIONS.chart then
  require 'rubygems'
  require 'scruffy'

  while scrub_failures(runs)
  end

  graph = Scruffy::Graph.new

  runs.each do |run|
    graph << run.line_chart
  end

  # Not useful until Scruffy can rotate x axis point markers
  # graph.point_markers = runs.shift.last.benchmarks.collect do |b|
  #   b.label.match(/[^:]: (.+)/)[1]
  # end

  puts "Rendering chart to #{OPTIONS.chart}"

  graph.render( :width => OPTIONS.width, :to => OPTIONS.chart )
end
