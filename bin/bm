#!/usr/bin/env ruby

require 'benchmark'
include Benchmark

require 'optparse'
require 'ostruct'

require 'rubygems'
require 'scruffy'

BM_GLOB      = 'test/benchmark/*/bm*.rb'
INTERPRETERS = ['ruby','shotgun/rubinius']
WIDTH        = 50

OPTIONS = OpenStruct.new( :grep => '.*' )

options = OptionParser.new do |opts|
  opts.on('-c',        '--chart [FILENAME]') { |c| OPTIONS.chart  = c || 'bm.svg' }
  opts.on('-g SEARCH', '--grep SEARCH')      { |g| OPTIONS.grep   = g }
  opts.on('-h',        '--help')             { |h| OPTIONS.help   = h }
  opts.on('-r',        '--no-report')        { |r| OPTIONS.report = r }
end

options.parse!

if OPTIONS.help then
  puts options.summarize
  exit
end

class RbxBenchmarkFile
  def initialize(interpreter,file)
    @interpreter = interpreter
    @file        = file

    run
  end

  def pretty_interpreter
    @interpreter.match(%r{ruby|rubinius})[0]
  end

  def pretty_file
    @file.match(%r{[^/]+/[^/]+$})[0]
  end

  def label
    pretty_interpreter + ': ' + pretty_file
  end

  def command
    command = "#{@interpreter} #{@file}"

    case @file
      when /wycats\/bm_string[.]rb/
        command += %{ -x "String#unpack"}
      when /borasky\/bm_MatrixBenchmark[.]rb/
        command += %{ 64}
    end

    command
  end

  def quiet_command
    command + ' > /dev/null 2>&1'
  end

  def run
    @result = Benchmark.bmbm do |x|
      x.report(label + ' ' * (WIDTH - label.length)) do
        if system quiet_command then
          @pass = true
        else
          @pass = false
          system command
        end
      end
    end.first
  end

  def pass?
    @pass
  end

  def time
    pass? ? @result.real : 0
  end
end

class RbxBenchmarkRun
  attr_reader :interpreter
  attr_reader :benchmarks

  def initialize(interpreter)
    @interpreter = interpreter
    @benchmarks  = []
    @total = Benchmark::Tms.new
  end

  def clean
    if @interpreter =~ /rubinius/ then
      Dir[BM_GLOB + 'c'].each do |file|
        File.unlink file
      end
    end
  end

  def run
    clean

    Dir[BM_GLOB].each do |file|
      next unless file.match(OPTIONS.grep)
      @benchmarks << RbxBenchmarkFile.new(@interpreter,file)
    end

    self
  end

  def time
    @benchmarks.inject(0) {|total, b| total + b.time }
  end

  def report
    puts
    puts @interpreter
    puts '-' * @interpreter.length

    @benchmarks.each do |benchmark|
      if benchmark.pass? then
        puts benchmark.time
      else
        puts "Failed"
      end
    end

    puts 'Total time, not including failures: ' + time.to_s
    puts
  end
end

results = {}

INTERPRETERS.each do |i|
  results[i] = RbxBenchmarkRun.new(i).run
end

if OPTIONS.report then
  results.each_value { |r| r.report }
end

if OPTIONS.chart then
  puts "Now saving chart to #{OPTIONS.chart}"
  graph = Scruffy::Graph.new

  results.each_value do |r|
    graph.add( :line, r.interpreter, r.benchmarks.collect { |b| b.time } )
  end

  graph.render( :to => OPTIONS.chart )
end
