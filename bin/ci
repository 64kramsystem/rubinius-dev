#! /usr/bin/env ruby
#
# ci - continuous integration tool
#

require 'optparse'

module CI
  VERSION = '0.5.0'
end

action = :run
patterns = []
target = 'shotgun/rubinius'
format = 'CIReporter'
clean = false
verbose = false
ci_files = "spec/files.txt"

opts = OptionParser.new("", 24, '   ') do |opts|
  opts.banner = "ci [options] (FILE|DIRECTORY|GLOB)+"
  opts.separator ""

  opts.on("-c", "--create", "Create the exclude file for failing specs") do
    action = :create
  end
  opts.on("-r", "--run", "Run the specs excluding the expected failures") do
    action = :run
  end
  opts.on("-i", "--invert", "Run the specs using only the expected failures") do
    action = :invert
    format = 'd'
  end
  opts.on("-t", "--target TARGET", String, 
          "Implementation that will run the specs: r:ruby|r19:ruby19|x:rbx|j:jruby") do |t|
    case t
    when 'r', 'ruby'
      target = 'ruby'
    when 'r19', 'ruby19'
      target = 'ruby19'
    when 'x', 'rbx', 'rubinius'
      target = 'shotgun/rubinius'
    when 'j', 'jruby'
      target = 'jruby'
    else
      target = t
    end
  end
  opts.on("-f", "--format FORMAT", String, 
          "Formatter for reporting: s:specdox|d:dotted|c:CI|h:html|i:immediate") do |f|
    case f
    when 's', 'specdox', 'specdoc'
      format = 'SpecDoxReporter'
    when 'h', 'html'
      format = 'HtmlReporter'
    when 'd', 'dot', 'dotted'
      format = 'DottedReporter'
    when 'c', 'ci', 'integration'
      format = 'CIReporter'
    when 'i', 'immediate'
      format = 'ImmediateReporter'
    else
      puts "Unknown format: #{f}"
      puts opts
      exit
    end
  end
  opts.on("-C", "--clean", "Remove all compiled spec files first") do
    clean = true
  end
  opts.on("-V", "--verbose", "Output each file processed when running") do
    verbose = true
  end
  opts.on("-v", "--version", "Show version") do
    puts "Continuous Integration Tool #{CI::VERSION}"
    exit
  end
  opts.on("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  patterns = opts.parse ARGV
end

# only these directories are included because other directories have specs
# that cause compilation to fail. ideally, spec/**/*_spec.rb would be run.
patterns = ['spec/compiler', 'spec/core', 'spec/mspec', 'spec/parser'] if patterns.empty?
files = []
patterns.each do |item|
  stat = File.stat(File.expand_path(item))
  files << item if stat.file?
  files.concat(Dir[item+"/**/*_spec.rb"]) if stat.directory?
end

# remove all compiled spec files to catch compiler bugs
if clean
  files.each do |name|
    cname = "#{name}c"
    File.delete(cname) if File.exist?(cname)
  end
end

def exclude(file)
  File.join(File.dirname(file), '.spec', File.basename(file, '.*').sub(/_spec$/, '_excludes') + '.txt')
end

def mk_exclude_dir(file)
  dir = File.join(File.dirname(file), '.spec')
  Dir.mkdir(dir) unless File.exist?(dir)
end

File.open(ci_files, "w") do |f|
  files.each do |file|
    mk_exclude_dir file
    f.print "#{file} #{exclude file}\n"
  end
end

cmd = <<-EOC
#{target} -Ispec -rmini_rspec.rb -rmini_mock.rb -e '
@runner = SpecRunner.new;
File.open(#{ci_files.inspect}, "r") do |f|
  f.each do |line|
    file, exclude = line.split
    reporter = #{format}.new(%s)
    @runner.reporter = reporter
    @runner.%s
    STDERR.puts file if #{verbose}
    load file
    reporter.summary
  end
end'
EOC

case action
when :create
  system(cmd % ['exclude', 'except("spec/excludes.txt")'])
when :run
  system(cmd % ['STDOUT', 'except("spec/excludes.txt", exclude)'])
when :invert
  system(cmd % ['STDOUT', 'only("spec/excludes.txt")'])
else
  puts "Unknown action: #{action}"
  puts opts
  exit
end
