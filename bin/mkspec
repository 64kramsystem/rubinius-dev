#! /usr/bin/env ruby
#
# mkspec - utility to create the appropriate file
# for specs for Ruby core library class/module methods

require 'optparse'
require File.dirname(__FILE__) + '/name_map'

module MkSpec
  VERSION = '0.0.1'

  def self.create_file(dir, name)
    file = File.join(dir, name)
    unless File.exist?(file)
      File.open(file, 'w') do |f|
        f.puts("require File.dirname(__FILE__) + '/../../spec_helper'\n")
      end
      puts file
    end
  end

  def self.generate(base, modules)
    modules.each do |mod|
      dir = NameMap.get_dir_name mod, base
      if File.exist?(dir)
        unless File.directory?(dir)
          puts "A file named #{dir} already exists and is not a directory."
          exit 1
        end
      else
        Dir.mkdir dir
      end

      methods = [
        mod.methods(false),
        mod.public_instance_methods(false),
        mod.private_instance_methods(false),
        mod.protected_instance_methods(false),
      ].flatten.uniq.sort

      methods.each do |method|
        name = NameMap.get_spec_name method, mod.name
        MkSpec.create_file dir, name unless File.exist?(name)
      end

      sub_mods = mod.constants.sort.map do |constant_name|
        NameMap.get_class_or_module "#{mod}::#{constant_name}"
      end.compact

      generate dir, sub_mods
    end
  end

  def self.process_args(argv)
    constants = []
    base = nil

    opts = OptionParser.new do |opts|
      opts.version = VERSION
      opts.banner = "mkspec [options]"
      opts.separator ""

      opts.on("-c", "--constant CONSTANT",
              "Class or Module to generate spec stubs for") do |name|
        constant = NameMap.get_class_or_module(name)

        if constant.nil? then
          raise OptionParser::InvalidArgument, "#{name} is not a constant"
        end

        constants << constant
      end

      opts.on("-b", "--base BASE",
              "Directory to generate specs into") do |directory|
        base = File.expand_path directory
      end

      opts.on("-r", "--require LIBRARY",
              "A library to require") do |file|
        begin
          require file
        rescue LoadError
          raise OptionParser::InvalidArgument, "#{file} could not be required"
        end
      end

      opts.parse argv
    end

    if constants.empty? then
      Object.constants.map { |const| NameMap.get_class_or_module(const) }
    end

    constants = constants.compact

    return base, constants
  rescue OptionParser::ParseError => e
    puts opts
    puts
    puts e
    exit 1
  end

  def self.run(argv = ARGV)
    base, constants = process_args argv

    generate base, constants
  end

end

MkSpec.run if __FILE__ == $0

