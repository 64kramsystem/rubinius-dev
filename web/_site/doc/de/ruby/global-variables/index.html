<p>Syntatically, a global variable is supposed to be a variable whose name begins
with <code>$</code>. Global variables are supposed to be available from any context in a
Ruby program. However, there are actually three different kinds of globals: true
globals, thread-local globals, and pseudo globals.</p>

<p>True globals associate a value with a global name, such as <code>$LOAD_PATH</code>.</p>

<p>Thread-local globals have the syntax of a global variable but there is a
different version of the global for each thread in the running Ruby process.
Examples of thread-local globals are <code>$SAFE</code> and <code>$!</code>. To see that these
values depend on the thread, consider the following code:</p>

<pre><code>puts $SAFE

Thread.new do
  $SAFE = 2
  puts $SAFE
end

puts $SAFE
</code></pre>

<p>Pseudo globals are a strict subset of names which refer not to global values
but values in the current scope, like local variables. These are still
referred to as global variables because they start with a dollar sign; this is
a source of confusion for users.</p>

<p>All pseudo globals are organized around one primary pseudo global: <code>$~</code>.  They
are all accessing parts of <code>$~</code> and thus when <code>$~</code> changes, they all
change.</p>

<p>The rest of the pseudo globals are: <code>$&amp;</code>, <code>$`</code> (backtick), <code>$'</code> (single
quote), <code>$+</code>, and <code>$1</code>, <code>$2</code>, <code>$3</code>, etc.</p>

<p>One tricky aspect of these values is that they are strictly bound to the
current scope but Ruby allows them to be aliased, as is done in English.rb.</p>

<p>These new aliases are basically adding new local variables to all scopes, even
ones already running. Thusly, Rubinius does not fully support them. Instead we
simply provide the aliases present in English.rb by default. For example,
<code>$MATCH</code> can be used instead <code>$~</code>, whether English.rb is included or not.</p>
