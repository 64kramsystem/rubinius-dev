<!DOCTYPE html>
<html>
  <head>
    <title>Rubinius : Use Ruby&#8482;</title>
    <meta content='text/html;charset=utf-8' http-equiv='content-type'>
    <meta content='en' http-equiv='content-language'>
    <meta content='Rubinius is an implementation of the Ruby programming language. The Rubinius bytecode virtual machine is written in C++. The bytecode compiler is written in pure Ruby. The vast majority of the core library is also written in Ruby, with some supporting primitives that interact with the VM directly.' name='description'>
    <meta content='Less Than Three. &lt;3. http://less.thanthree.com' name='author'>
    <link href='/' rel='home'>
    <link href='/' rel='start'>
    
    
    <link href='/feed/atom.xml' rel='alternate' type='application/atom+xml' title='Rubinius Blog' />
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script><![endif]-->
    <script src="/javascripts/jquery-1.3.2.js" type="text/javascript"></script>
    <script src="/javascripts/paging_keys.js" type="text/javascript"></script>
    
    <script src="/javascripts/application.js" type="text/javascript"></script>
    <style>article, aside, dialog, figure, footer, header, hgroup, menu, nav, section { display: block; }</style>

    <link href="/stylesheets/blueprint/screen.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/application.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/blueprint/print.css" media="print" rel="stylesheet" type="text/css" />
    <!--[if IE]><link href="/stylesheets/blueprint/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <!--[if IE]><link href="/stylesheets/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/pygments.css" media="screen" rel="stylesheet" type="text/css" />
  </head>
    <body>
        <div class='container'>
      <div class='span-21 blog_menu'>
        <header>
                    <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a id="blog" href="/blog/">Blog</a></li>
              <li><a id="documentation" href="/doc/en/">Documentation</a></li>
              <li><a href="/projects/">Projects</a></li>
              <li><a href="/roadmap/">Roadmap</a></li>
              <li><a href="/releases/">Releases</a></li>
            </ul>
          </nav>

        </header>
      </div>
            <div class='span-3 last'>
        <div id='version'>
          <a href="/releases/1.2.2">1.2.2</a>
        </div>
      </div>

    </div>

            <div class="container posts_nav">
      <nav>
        <a href="/blog/posts_index/">Index of Posts</a>
        <a id="feed_icon" href="/feed/atom.xml"><img alt="subscribe" src="/images/feed-icon16x16.png" /></a>
      </nav>
    </div>


  <div class="container blog_posts">
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/23/introduction-to-fancy/" title="Introduction to Fancy" class="post_title">
        Introduction to Fancy
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Christopher Bertels</span>
          <span class="date">23 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/23/introduction-to-fancy/#disqus_thread"
            data-disqus-identifier="/2011/02/23/introduction-to-fancy/"></a>

          
        </p>
      </div>

      <p>Fancy is a new general-purpose programming language targetting the
Rubinius VM.</p>

<p>This blog post will give a short introduction to the language, what
kind of problems it&rsquo;s trying to solve and why I chose Rubinius as the
VM to run Fancy on.</p>

<h3 id="what-is-fancy">What is Fancy?</h3>

<p>Fancy is a new general-purpose, dynamic, pure object-oriented
programming language heavily inspired by Ruby, Smalltalk and Erlang
that runs on the Rubinius VM. It&rsquo;s the first fully bootstrapped
language, aside from Ruby, running on Rubinius. This means that the
compiler that generates bytecode for Rubinius is written in Fancy
itself.</p>

<p>You can think of Fancy as a mix of features from the mentioned
languages above, taking each of their strengths and improving upon
their weaknesses.
Fancy has a very small core and is largely based on the concept of
message passing, just like Smalltalk. It tries to have as many
language concepts being first-class values in the language.</p>

<p>Just like Ruby, Fancy is a dynamic object-oriented language that
allows changing code at runtime, everything being an expression and
generally embracing more then one way to do things. Fancy also has all
the literal support that Ruby has, plus literal syntax for Tuples and
Patterns (more on that below).</p>

<p>In contrast to Ruby and just like Smalltalk, Fancy has a very small
amount of built-in keywords and all of the control structures are
implemented in terms of message sends to objects using closures.</p>

<p>The third language that served as an inspiration is Erlang, from which
Fancy takes the idea that concurrent programming should be easy by
having the Actor Model built into the language. This part is still a
work in progress, but should come together soon. The fact that
Rubinius has a built-in Channel type, inter-VM communication
capabilities and even an actor library makes implementing this easier
than in traditional systems.</p>

<h3 id="why-fancy">Why Fancy?</h3>

<p>I believe there is real value in having a language that supports
certain things out of the box. Especially when it comes to things like
asynchronous and concurrent programming, having proper semantics built
into the language can often help developers more than a library can.
Very often it&rsquo;s not just about the functionality itself but also about
the semantics you want that functionality to have. This can cause
problems particularly if the language&rsquo;s semantics differ from what
your library is trying to solve. A good example is the callback-based
approach to asynchronous progamming which leads to code that differs
both in semantics as well as how code is structured, compared to
synchronous code. Ideally you&rsquo;d still want to write code in a
synchronous fashion, where exceptions pop up naturally while still
being highly asynchronous.</p>

<p>In that sense Fancy is more flexible than Ruby as there&rsquo;s not many
special case semantics built in to the core language. Everything&rsquo;s
done via message passing, which fits nicely the actor model approach
to concurrency. Fancy&rsquo;s syntax is a lot simpler, too.</p>

<p>Since all the core control structures are just implemented in Fancy
itself and adhere to the message passing protocol, you can easily
override them for your personal needs. This is especially interesting
when implementing domain specific languages.
Say, you&rsquo;d want to add some logging to conditional or looping
constructs - it&rsquo;s as easy as overriding a method in your DSL&rsquo;s
classes. Fancy also has class-based mixins, so it makes it easy to
share functionality across class hierarchy boundaries.</p>

<p>Finally, I created Fancy because I wanted a language implementation
that was well documented, easy to understand and very flexible to
extend. Ruby is a nice language, but it has some inconsistencies and
there&rsquo;s only so much you can do when you&rsquo;re bound by backwards
compatibility. By starting fresh, Fancy has a clean, simple and easy
to extend core which allows further exploration of features and
abstractions.</p>

<h3 id="why-target-rubinius">Why target Rubinius?</h3>

<p>The initial implementation of Fancy was a simple interpreter written
in C++, similar to how Ruby 1.8 (MRI) works. It was a simple AST
walker. After moving to Rubinius and writing an initial bootstrap
compiler in Ruby, the codebase shrank to about 20% of the original
implementation while actually being more performant. This of course is
mostly due to Rubinius&rsquo; architecture and JIT compiler but it was a
great experience nontheless.</p>

<p>The nice part about having a common virtual machine and runtime is
that you&rsquo;re not forced to a completely different platform to get the
job done. Fancy and Ruby can coexist in the same application nicely
and calling code from one another is dead simple. In fact, as of now,
Rubinius doesn&rsquo;t know anything about Fancy. And it shouldn&rsquo;t. As long
as all languages running on top of it adhere to the same interface
(in this case the bytecode), it should just work fine.</p>

<p>Choosing Rubinius as a successor platform for Fancy was easy. It&rsquo;s
built for Ruby, a language that&rsquo;s closely related to Fancy. Rubinius,
while having been developed as a VM for running Ruby code, is very
flexible and there are many features that abstract over Ruby&rsquo;s
external semantics. It was just a natural choice given the fact that
Rubinius&rsquo; architecture and design was heavily influenced by Smalltalk
VMs. Also, it&rsquo;s a very nice dynamic bytecode virtual machine. The
community is very responsive and helpful. Bugs get fixed instantly,
there&rsquo;s always someone to help out and overall it&rsquo;s been a great
experience.</p>

<h3 id="lets-look-at-some-code">Let&rsquo;s look at some code!</h3>

<p>OK, enough talking. Let&rsquo;s have a look on how to get some Fancy code up
and running. Our little sample application will be a simple IRC bot
that connects to Fancy&rsquo;s irc channel on Freenode and says hello to
everyone that greets it. To make life easier, there&rsquo;s already a Fancy
package out there that helps with exactly this task:
<a href="https://github.com/bakkdoor/fancy_irc">FancyIRC</a>.</p>

<p>FancyIRC is a simple IRC client library inspired by Ruby&rsquo;s IRC bot
framework <a href="https://github.com/cinchrb/cinch">Cinch</a>. It&rsquo;s much simpler
and the code is fairly easy to read, but it gives you a similar
interface for writing IRC clients or bots.</p>

<p>So let&rsquo;s get going by installing Fancy. You can either use the Fancy
Rubygem and install it with Rubinius or get the code from GitHub and
run <code>rake</code> in the directory. You&rsquo;ll also then have to add the <code>bin</code>
directory to your <code>$PATH</code>. If you want the latest and greatest version
of Fancy I recommend building directly from source, as the Gem might
not be up to date all the time. For demonstration purposes, let&rsquo;s
install the Rubygem.</p>

<pre><code>$ rbx -S gem install fancy
</code></pre>

<p>To get the FancyIRC package we use Fancy&rsquo;s built-in package manager,
which knows how to find the code on GitHub and install it locally:</p>

<pre><code>$ fancy install bakkdoor/fancy_irc
</code></pre>

<h4 id="writing-the-code">Writing the code</h4>

<div class="highlight"><pre><code class="fancy"><span class="lineno"> 1</span> <span class="nf">require:</span> <span class="s">&quot;fancy_irc&quot;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="n">greeter_bot</span> <span class="o">=</span> <span class="no">FancyIRC</span> <span class="no">Client</span> <span class="nf">new:</span> <span class="p">{</span>
<span class="lineno"> 4</span>   <span class="nf">configuration:</span> <span class="p">{</span>
<span class="lineno"> 5</span>     <span class="nf">nickname:</span> <span class="s">&quot;greeter_bot&quot;</span>
<span class="lineno"> 6</span>     <span class="nf">server:</span> <span class="s">&quot;irc.freenode.net&quot;</span>
<span class="lineno"> 7</span>     <span class="nf">port:</span> <span class="mi">6667</span>
<span class="lineno"> 8</span>     <span class="nf">channels:</span> <span class="o">[</span><span class="s">&quot;#fancy&quot;</span><span class="o">]</span>
<span class="lineno"> 9</span>   <span class="p">}</span>
<span class="lineno">10</span> 
<span class="lineno">11</span>   <span class="c1"># greet person back</span>
<span class="lineno">12</span>   <span class="nf">on:</span> <span class="ss">&#39;channel</span> <span class="nf">pattern:</span> <span class="sr">/^[hH]ello greeter_bot/</span> <span class="nf">do:</span> <span class="p">|</span><span class="n">msg</span><span class="p">|</span> <span class="p">{</span>
<span class="lineno">13</span>     <span class="n">msg</span> <span class="nf">reply:</span> <span class="s">&quot;Hello to you too, #{msg author}!&quot;</span>
<span class="lineno">14</span>   <span class="p">}</span>
<span class="lineno">15</span> 
<span class="lineno">16</span>   <span class="c1"># &quot;echo&quot; command</span>
<span class="lineno">17</span>   <span class="c1"># invoke with: !echo &lt;text&gt;</span>
<span class="lineno">18</span>   <span class="nf">on:</span> <span class="ss">&#39;channel</span> <span class="nf">pattern:</span> <span class="sr">/^!echo (.*)$/</span> <span class="nf">do:</span> <span class="p">|</span><span class="n">msg</span><span class="o">,</span> <span class="n">text</span><span class="p">|</span> <span class="p">{</span>
<span class="lineno">19</span>     <span class="n">msg</span> <span class="nf">reply:</span> <span class="s">&quot;#{msg author} said: #{text}&quot;</span>
<span class="lineno">20</span>   <span class="p">}</span>
<span class="lineno">21</span> 
<span class="lineno">22</span>   <span class="c1"># tell bot to shutdown via !shutdown command</span>
<span class="lineno">23</span>   <span class="nf">on:</span> <span class="ss">&#39;channel</span> <span class="nf">pattern:</span> <span class="sr">/^!shutdown/</span> <span class="nf">do:</span> <span class="p">|</span><span class="n">msg</span><span class="p">|</span> <span class="p">{</span>
<span class="lineno">24</span>     <span class="n">msg</span> <span class="nf">reply:</span> <span class="s">&quot;OK, shutting down&quot;</span>
<span class="lineno">25</span>     <span class="no">System</span> <span class="n">exit</span>
<span class="lineno">26</span>   <span class="p">}</span>
<span class="lineno">27</span> <span class="p">}</span>
<span class="lineno">28</span> 
<span class="lineno">29</span> <span class="n">greeter_bot</span> <span class="n">connect</span>
<span class="lineno">30</span> <span class="n">greeter_bot</span> <span class="n">run</span>
</code></pre>
</div>

<p>I think the code is pretty straight forward. This should give you a
feeling for what Fancy looks and feels like. There is of course lots
more to Fancy than what was shown here. It would not fit into a single
blog post.</p>

<p>A quick list of what&rsquo;s currently being worked on:</p>

<ul>
  <li>New pattern matching system: Message passing based pattern matching
that preserves encapsulation and is very extensible including
pattern literals that allow custom pattern types to be defined by
anyone. There&rsquo;s an experimental branch for that. I&rsquo;m happy
to answer questions.</li>
  <li>Async support using coroutines (Fibers) - Write async code in a more
natural way where exceptions propagate naturally and you don&rsquo;t have
to think about callbacks all the time.</li>
  <li>First-class support for actors - Asynchronous message sends, Futures
and multi-vm messaging built-in.</li>
  <li>And much more&hellip;</li>
</ul>

<h3 id="interested">Interested?</h3>

<p>If you got interested in Fancy and want to know where to go next,
here&rsquo;s a short list of things to check out:</p>

<ul>
  <li><a href="https://github.com/bakkdoor/fancy">Fancy&rsquo;s GitHub repository</a>.
The standard library is completely written in Fancy and most classes
and methods have docstrings. It should be fairly easy to understand.</li>
  <li><a href="https://github.com/fancy-lang/infancy">Programming InFancy</a>
An open source tutorial on learning Fancy. Work in progress.</li>
  <li><a href="http://api.fancy-lang.org">http://api.fancy-lang.org</a>
A work in progress page containing Fancy&rsquo;s standard library class
and method documentation.</li>
  <li><a href="https://groups.google.com/forum/#!forum/fancy-lang">Fancy&rsquo;s Google Group mailinglist</a></li>
  <li>IRC Channel: #fancy @ irc.freenode.net</li>
  <li>Website: <a href="http://www.fancy-lang.org">http://www.fancy-lang.org</a></li>
</ul>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/22/rubinius-multiple-branches-with-rvm/" title="Running Multiple Rubinius Branches Simultaneously with RVM." class="post_title">
        Running Multiple Rubinius Branches Simultaneously with RVM.
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Wayne E. Seguin</span>
          <span class="date">22 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/22/rubinius-multiple-branches-with-rvm/#disqus_thread"
            data-disqus-identifier="/2011/02/22/rubinius-multiple-branches-with-rvm/"></a>

          
        </p>
      </div>

      <p>This article is written with the assumption that you have RVM installed
already. If you do not, follow the
<a href="http://rvm.beginrescueend.com/rvm/install/">Installation Instructions</a>
followed by the
<a href="http://rvm.beginrescueend.com/rvm/basics/">Basics</a>
closely first.</p>

<h3 id="named-ruby-installs">Named Ruby Installs</h3>

<p>Everyone familiar with RVM knows that it allows you to quickly and
easily install a particular Ruby interpreter by simply running, for
example,</p>

<pre><code>rvm install rbx
</code></pre>

<p>What is not widely known (yet) is that there is a &ldquo;Named Rubies&rdquo; feature
that allows you to install altered versions of the same Ruby
installation along side the original.</p>

<p>In the case of Rubinius there is this facinating branch called &lsquo;hydra&rsquo;.
So let us see how we can have the Rubinius master branch installed as
the main rbx with the hydra branch installed along side as well.</p>

<p>As above you first install rbx which is currently defaulted to -head
version so</p>

<pre><code>rvm install rbx
</code></pre>

<p>is currently equivalent to</p>

<pre><code>rvm install rbx-head
</code></pre>

<p>After we have the mainline head Rubinus branch installed, we now want to
use the named rubies feature. This is done using the -n specifier in the
Ruby identifier string. So for example to install our hydra branch as an
RVM ruby with the name &lsquo;hydra&rsquo; in it we do the following:</p>

<pre><code>rvm install --branch hydra rbx-nhydra
</code></pre>

<p>Now we can see that they can be used together! Using the Rubinius master
environment,</p>

<pre><code>$ rvm rbx ; ruby -v
rubinius 1.2.1 (1.8.7 6feb585f 2011-02-15 JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>Whereas using the Rubinius hydra environment,</p>

<pre><code>$ rvm rbx-nhydra ; ruby -v
rubinius 1.3.0dev (1.8.7 6feb585f xxxx-xx-xx JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>We see that the next release of Rubinius (hydra branch) is indeed
version 1.3.0 whereas the master branch is version 1.2.1.</p>

<p>Also please note that RVM creates wrapper scripts, so you do not need to
switch out the entire environment just to run the differen versions
either:</p>

<p>For Rubinius master,</p>

<pre><code>$ rbx-head -v
rubinius 1.2.1 (1.8.7 6feb585f 2011-02-15 JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>For Rubinius hydra,</p>

<pre><code>$ rbx-head-nhydra -v
rubinius 1.3.0dev (1.8.7 6feb585f xxxx-xx-xx JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>There is a lot more available to you than this, for more information on
RVM capabilities please visit the <a href="http://rvm.beginrescueend.com/">RVM
Website</a> and also come talk to us in #rvm on
irc.freenode.net during the daytime EDT.</p>

<p>I hope that this is helpful and informative to you!</p>

<p>~Wayne</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/17/rubinius-what-s-next/" title="Rubinius, What's Next?" class="post_title">
        Rubinius, What's Next?
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">17 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/17/rubinius-what-s-next/#disqus_thread"
            data-disqus-identifier="/2011/02/17/rubinius-what-s-next/"></a>

          
        </p>
      </div>

      <p>On Tuesday, we released version 1.2.1 (see the <a href="http://rubini.us/releases/1.2.1/">Release
notes</a>). This release weighs in at 256
commits and 21 tickets closed in the 56 calendar days since the release of
1.2.0. Many thanks to those who contributed patches and to everyone who helped
us test it.</p>

<p>While we were working on 1.2.1, we were also working on a Top Secret project
that we&rsquo;ve craftily <a href="https://github.com/evanphx/rubinius/tree/hydra">hidden in plain
sight</a>. I&rsquo;d like to introduce
the work we are doing on the hydra branch and the features you can expect to
see in Rubinius soon.</p>

<h3 id="daedalus---a-new-build-system">Daedalus - A new build system</h3>

<p>Rubinius is a fairly complex project. It combines multiple components into a
single system. We have worked hard to contain this complexity and from the
beginning we insisted that building Rubinius be as simple as possible. For
example, Rubinius can be run from the source directory, there is no need to
install it first. Typically, building requires:</p>

<pre><code>./configure
rake
</code></pre>

<p>The Rubinius system combines:</p>

<ol>
  <li>External libraries written in C/C++, sometimes built with just Makefiles
and sometimes using autotools.</li>
  <li>The virtual machine, garbage collector, and JIT compiler written in C++.</li>
  <li>The virtual machine interpreter instructions, including support code for
the JIT, and instruction documentation all generated at build time from an
instruction template.</li>
  <li>The core library and bytecode compiler written in Ruby.</li>
  <li>Various C extensions like the Melbourne parser, BigDecimal, Digest, and
OpenSSL libraries. In the case of the parser, we have to build <em>two</em>
versions, one for the bootstrapping system and one for the Rubinius system
being built.</li>
</ol>

<p>It has not been easy to make this work and over the years we have compiled a
list of exactly what we need in a build system. Evan, in typical form, started
hacking out a first pass and created <em>daedalus</em>, our new build system. It
features such exotic (and extremely useful) features as SHA-based change
detection, parallel builds, single-process execution, and use-aware
configuration options. Allow me to elaborate.</p>

<ul>
  <li>A typical build system decides to rebuild a file if the source is newer than
the build artifact. This can result is unnecessarily building files that
have been touched by some process (like updating from the source repository)
but whose contents have not changed.  By basing rebuild decisions on the SHA
digest of the source, only files that have actually been changed need to be
built. Since compiling C++ with optimizations is <em>not</em> a fast process,
eliminating unnecessary building is great for productivity, not to mention
global warming.</li>
  <li>With a multi-core system, builds can be done faster if they are done in
parallel. If the build system can accurately determine dependencies, it can
execute build sub-steps in parallel. Of course, this can cut into YouTube
and Twitter browsing time, but that&rsquo;s a risk we are willing to take.</li>
  <li>While parallel sub-processes during the build are excellent, the supervising
process benefits from running as a single process from start to finish.
Otherwise, configuration data needs to be re-parsed. To support a single
build process, we need multiple, independent dependency graphs for the
components. As noted above, we need to build two versions of the parser,
which requires two dependency graphs <em>for the same component</em>! This is
simply impossible in Rake.</li>
  <li>Use-aware configuration values know that the user has set the value and can
intelligently merge with newer configuration variables that we create
without requiring the user to reconfigure. Ultimately, we are aiming for a
<em>single</em> command build. Just run &lsquo;daedalus&rsquo; and done. There is no step 2.</li>
</ul>

<h3 id="full-on-concurrency">Full-on Concurrency</h3>

<p>Nobody likes waiting in line. In fact, the more desirable a thing is, the less
we want to stand idly waiting in a line for it, tapping our foot, twiddling
our thumbs. The same could be said about our programs.</p>

<p>Threads give us the ability to add concurrency to our programs. However,
unless the hardware either has multiple CPUs or multiple cores per CPU (or
both), the apparent concurrency will still be executing serially. Since there
are so many multi-core CPUs around these days, our programs should be getting
stuff done in parallel.</p>

<p>Unfortunately, there&rsquo;s a twist. Even with native threads on a multi-core CPU,
the amount of parallelism you get depends on how well you manage locks around
shared data and resources. Sometimes managing these locks is complex and you
opt for one big lock, essentially only allowing one thread at a time to run.
That big lock is usually called a global interpreter lock (GIL) or global VM
lock (GVL).</p>

<p>The Rubinius VM originally had green (user-space) threads, but it has had
native threads with a GIL for a while now. In the hydra branch, Evan and
contributors like Dirkjan Bussink have been working on replacing the GIL with
fine-grained locks so that threads truly execute in parallel. This work has
been going very well, owing in part to the fact that so much code in Rubinius
is actually written in Ruby. Contributors like Chuck Remes have been running
hydra under heavy concurrency loads and Rubinius is performing well.</p>

<p>Rubinius also has experimental support for Fibers and a built-in Actor
library. There is more work to be done but Rubinius is quickly becoming an
excellent platform for concurrency, with a variety of approaches available to
the programmer. Evan has also suggested rewriting the Rubinius IO subsystem to
enable even better APIs for concurrency, all from Ruby.</p>

<h3 id="performance">Performance</h3>

<p>Forget everything anyone has ever told you about Ruby being slow. There are
two things that make Ruby, as implemented, slow: 1) inexperience; 2)
inadequate tools. These two result in one big thing: <em>doing too much</em>. Or, as
they say: <em>No code runs faster than no code</em>. We have been working for 4+
years to build adequate tools in Rubinius, and there is plenty of experience
in Smalltalk, Self, and other languages for making dynamic languages fast.</p>

<p>Presently, Rubinius typically runs pure Ruby code almost 2 times faster than
MRI 1.9. However, there are also cases where Rubinius is slower. These mostly
involve core libraries that are implemented in C in MRI. There are three main
fronts on which we are attacking performance issues: 1) improving the
algorithms in the Ruby code that implements the core library; 2) continuing to
tune the VM and garbage collector; and 3) improving the JIT compiler. Which
leads me to one of the most exciting things we are working on&hellip;</p>

<h3 id="jit-intermediate-representation-ir">JIT Intermediate Representation (IR)</h3>

<p>The just-in-time (JIT) compiler is the key to making Ruby fast. One of the
biggest challenges with a dynamic language like Ruby is knowing what method is
actually being invoked when a message is sent to an object. Consider the
following code:</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">A</span>
<span class="lineno"> 2</span>   <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="lineno"> 3</span>     <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="lineno"> 4</span>   <span class="k">end</span>
<span class="lineno"> 5</span> <span class="k">end</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="k">class</span> <span class="nc">B</span>
<span class="lineno"> 8</span>   <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="lineno"> 9</span>     <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="lineno">10</span>   <span class="k">end</span>
<span class="lineno">11</span> <span class="k">end</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="k">class</span> <span class="nc">C</span>
<span class="lineno">14</span>   <span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="lineno">15</span>     <span class="n">obj</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="lineno">16</span>   <span class="k">end</span>
<span class="lineno">17</span> <span class="k">end</span>
</code></pre>
</div>

<p>What method is being invoked by <code>obj.m(y)</code>? There is no way to definitively
know this by looking at the source code. However, when the program is actually
running, we can know precisely what <code>obj</code> is and precisely which method <code>m</code>
was invoked. This is called type profiling and that is exactly what the Rubinius
VM does. Then the JIT uses the type information to make decisions like whether
to inline a method into another method. When methods are inlined, it gives the
optimizer more data and more possibilities to remove redundant code. The less
code we can run, the faster Ruby will be.</p>

<p>Presently, the JIT compiler converts Rubinius bytecode into LLVM IR and LLVM
handles the thorny task of generating machine code. However, Rubinius bytecode
is designed for fast execution by the virtual machine rather than as a rich
intermediate representation. So Evan has started work on a new JIT IR.</p>

<p>This new IR will help us to express Ruby semantics in a way that enables many
powerful optimizations and will ultimately allow LLVM to generate even better
machine code. Put another way, <em>Rubinius loves Ruby code!</em> Right down to the
metal. There&rsquo;s no fighting a foreign type system or the semantics of a
language at odds with Ruby&rsquo;s rosy view of the world.</p>

<h3 id="ruby-19">Ruby 1.9</h3>

<p>MRI 1.9 introduced two completely different changes to Ruby. The first was a
new implementation based on a bytecode virtual machine. While the virtual
machine replaced the AST-walking interpreter, little else changed
architecturally. Mostly the same core library and garbage collector code
exists in MRI 1.9 as was in MRI 1.8. The second change introduced some new
syntax (minor) and encodings (major). Many of the other changes, for example,
returning Enumerator objects from methods that take blocks, have been
back-ported to Ruby 1.8.7 and are already available in Rubinius.</p>

<p>So, the key to supporting Ruby 1.9 in Rubinius essentially involves supporting
the 1.9 syntax changes and encodings. We have begun implementing the parser
changes and introduced the foundation for Encoding-aware Strings. A good
amount of work remains to be done, but over the next month we expect that
we will be starting to run Ruby 1.9-specific code in Rubinius.</p>

<h3 id="tools-of-information">Tools of Information</h3>

<p>It has been said that <code>printf</code> is the mother of all debuggers. That
illustrates two points: 1) data is often buried in our program code; and 2) we
should have tools (e.g. a debugger) that enables us to access the data without
manually instrumenting our code.</p>

<p>Presently, Rubinius has a built-in debugger, precise method profiler, memory
analysis tool, and Agent interface that permits querying a running Rubinius
VM&ndash;even one running on a remote machine&ndash;for a variety of information.</p>

<p>We will be adding the ability to track the location where objects are
allocated to assist finding object leaks or code that is creating unusually
large numbers of objects. We are also working on a tool to graphically display
information like number of running threads, amount of CPU usage, and amount of
memory used while actively monitoring a VM.</p>

<p>I am also curious about correlating this VM information with external data to
enable play-back review.  For example, I would like to monitor RubySpec runs
and correlate which spec is running with the VM data. I imagine a simple
monotonic reference ID provided by the VM would be useful in correlating these
two otherwise unrelated pieces of data. The RubySpec runner would request the
ID before running each spec and the Agent monitor would request the ID when
gathering VM data. Later the two data sets could easily be merged.</p>

<p>When you find yourself manually instrumenting some code, consider what data
you are trying to get your hands on and let us know the scenario.  We&rsquo;ll
likely be able to build a tool that will open up new vistas into the behavior
of your Ruby programs.</p>

<h3 id="windowssupregsup">Windows<sup>&reg;</sup></h3>

<p>However one may feel about Windows as an operating system, it is undeniable
that the vast majority of people in the world use Windows. We believe those
people have an inalienable right to use Rubinius, too.</p>

<p>Thanks to the wonderful, hard-working
<a href="http://mingw-w64.sourceforge.net/">MinGW-w64</a> folks, we are able to compile
the Rubinius VM into a native Windows executable. Presently, the VM will
compile, link, and attempt to load the Ruby core library. More
platform-specific work is needed to load the library. The next step after that
will be getting the RubySpecs to run and start fixing issues.</p>

<p>Since the Windows work is being done on the hydra branch, the other features
discussed above will be available on Windows as soon as we complete them.</p>

<h3 id="multi-language-ualization">Multi-language-ualization</h3>

<p>The Rubinius VM began as an effort to create a modern, first-class environment
for running programs written in Ruby. However, it turns out that Ruby is a
terrific language for writing subsystems for other programming languages.
Actually, this should come as no surprise; Ruby is a fabulous general purpose
programming language.</p>

<p>To support experimenting with writing other languages that run on the Rubinius
VM, Evan has started to put together a Language Toolkit. This includes things
like a built-in PEG parser, convenient ways to create methods from Rubinius
bytecode, and decoupling method dispatch from Ruby semantics.</p>

<p>Hopefully, Evan will introduce us to all this in a future blog post, but
here is a taste of what you can do:</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">Hello</span>
<span class="lineno"> 2</span>   <span class="n">dynamic_method</span> <span class="ss">:world</span> <span class="k">do</span> <span class="o">|</span><span class="n">g</span><span class="o">|</span>
<span class="lineno"> 3</span>     <span class="n">g</span><span class="o">.</span><span class="n">push</span> <span class="ss">:self</span>
<span class="lineno"> 4</span>     <span class="n">g</span><span class="o">.</span><span class="n">push_literal</span> <span class="s2">&quot;Hello, world&quot;</span>
<span class="lineno"> 5</span>     <span class="n">g</span><span class="o">.</span><span class="n">send</span> <span class="ss">:puts</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kp">true</span>
<span class="lineno"> 6</span>     <span class="n">g</span><span class="o">.</span><span class="n">ret</span>
<span class="lineno"> 7</span>   <span class="k">end</span>
<span class="lineno"> 8</span> <span class="k">end</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="no">Hello</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">world</span>
</code></pre>
</div>

<p>Of course, that is much more concisely written in Ruby, but combine this
ability with a built-in PEG parser and you can be experimenting with your own
fascinating syntax in a matter of minutes.</p>

<p>Check out the Rubinius <a href="http://rubini.us/projects/">Projects page</a> for some of
these language experiments. One language in particular is
<a href="https://github.com/bakkdoor/fancy">Fancy</a>, which is fully bootstrapped (i.e.
the Fancy compiler is now written in Fancy) on Rubinius.</p>

<h3 id="documentation">Documentation</h3>

<p>One the one hand, Rubinius just runs Ruby code, and you shouldn&rsquo;t need any
special knowledge to run your application on Rubinius. On the other hand, as
I&rsquo;ve discussed above, there are some specific Rubinius features that may be
very helpful to you. However, they can only be as helpful as the documentation
we have for them.</p>

<p>Before we released 1.2.0 in December last year, I spent quite a bit of time
getting a new documentation system in place. Since then, we&rsquo;ve had
contributors help with translations to Russian, Polish, Spanish, and German.
Adam Gardiner started documenting the garbage collector algorithms. Yehuda
Katz (you may have heard the name) has contributed documentation for <a href="http://rubini.us/doc/en/bytecode-compiler/">the
bytecode compiler</a> complete with
diagrams!. Chuck Remes wrote up a great piece on the <a href="http://rubini.us/doc/en/tools/memory-analysis/">memory
analysis</a> tool.</p>

<p>We really appreciate these contributions. We understand the need for great
documentation and we have been creating better support for it. In many cases,
all that is needed is to just open a file and start writing. Of course, one
cannot expect to understand much about Rubinius without digging into the code.
If there is a particular part of Rubinius that you are curious about, jump in
the #rubinius channel on freenode.net and ask us questions. We can point you
in the right direction and help clarify things. If nothing else, let us know
which part of the missing documentation is most important to you and we can
start filling that in.</p>

<h3 id="how-you-can-help">How you can help</h3>

<p>There you have it, some super exciting things coming very soon for Rubinius
and for Ruby! We would love to have your help making Rubinius even better. The
most important thing you can do is try running your Ruby code. Give us
feedback. Let us know what features or tools would make your life easier. Help
us to build them.</p>

<p>Rubinius adopts Ruby&rsquo;s rosy view of the world. We want to empower you to solve
your hardest problems with Ruby, and have fun doing it.</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2010/12/15/rubinius-has-a-blog/" title="Rubinius Has a Blog!" class="post_title">
        Rubinius Has a Blog!
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">15 December 2010</span>
          
                      <a href="http://rubini.us/2010/12/15/rubinius-has-a-blog/#disqus_thread"
            data-disqus-identifier="/2010/12/15/rubinius-has-a-blog/"></a>

          
        </p>
      </div>

      <p>Many thought the day would never come, but Rubinius finally has a blog. That&rsquo;s
not all, though: We have integrated the website, blog, and documentation using
Jekyll. The source code for it all is in the main <a href="http://github.com/evanphx/rubinius">Rubinius
repository</a>.</p>

<p>People have often requested that we write more about the <em>awesome</em> features in
Rubinius. We hear you and we&rsquo;d love to do this. However, there is always a
trade-off between working on those awesome features and writing about them.
Until now, it&rsquo;s been rather painful to write docs or blog posts because we did
not have good infrastructure in place. Now, I think we do. I&rsquo;m sure there are
still a lot of improvements we can make, but we have a good place to start.
I&rsquo;d like to give a brief tour of our new system.</p>

<p>The primary goal was to improve collaboration and reduce friction for writing
new documentation and blog posts. That&rsquo;s right, improve collaboration. There
are many people who have experience developing Rubinius and running their
applications on it. We love how people have collaborated with source code
commits. Now anyone has the ability to write a blog post as well. I&rsquo;ve written
a basic <a href="/doc/en/how-to/write-a-blog-post/">How-To - Write a Blog Post</a>
document. If you have an idea for a blog post, just let us know. We will
exercise a bit of editorial control just to ensure the topics are appropriate
for Rubinius, but generally, we are thrilled to have your contributions.</p>

<p>Recently, we added the <code>rbx docs</code> command. This will run a web server on your
machine and open a browser window to display the Rubinius documentation. Now
the documentation will also be available at the <a href="http://rubini.us">rubini.us</a>
website. I have added a basic outline and a bunch of files to further simplify
the task of writing docs. In many cases, merely open a file and start writing
docs in <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a> format.</p>

<p>We have also begun translating our documentation to other languages. I am
excited about this, being a huge language geek. I wish that I were proficient
in 10 languages so I could polish our documentation for the many people who
are not native English speakers. Alas, I only have a fair ability to write in
Spanish, so we are again depending on your help. I started the translation
effort by passing the existing English docs through Google translate. We have
a beginning guide for <a href="/doc/en/how-to/translate-documentation">How-To - Translate
Documentation</a>. I&rsquo;ve been told by
<em>kronos_vano</em> in our #rubinius IRC channel that he&rsquo;s already working on a
Russian translation. I personally would love to see Japanese and Chinese
translations.</p>

<p>So that&rsquo;s a brief introduction to our new infrastructure for documenting and
explaining Rubinius. It&rsquo;s been such a joy to see so many people contribute to
the Rubinius source code over the years. We hope that the blog, documentation,
and translations will further empower people to contribute and benefit from
the value that Rubinius has to offer the Ruby community.</p>

<p><em>¡Adelante!</em></p>

    </div>
  
  </div>

        <footer>
      <div class='container'>
        <nav>
          <ul>
            <li><a href="http://twitter.com/rubinius">Follow Rubinius on Twitter</a></li>
            <li><a href="http://github.com/evanphx/rubinius">Fork Rubinius on github</a></li>
            <li><a href="http://engineyard.com">An Engine Yard project</a></li>

            <li id='credit'>
              Site design by
              <a href="http://less.thanthree.com">Less Than Three</a>
            </li>
          </ul>
        </nav>
      </div>
    </footer>
        <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>

        <script type="text/javascript">
        try {
        var pageTracker = _gat._getTracker("UA-12328521-1");
        pageTracker._trackPageview();
        } catch(err) {}</script>


    <script type="text/javascript">
        var disqus_shortname = 'rubinius';

        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
  </body>

</html>
