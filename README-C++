 Running the C++ Branch
------------------------

+  Set up an altogether new clone of the repository for yourself:
    - For current committers:
        `cd $WHEREVER; git clone git@github.com:evanphx/rubinius.git`
    - For others: `cd $WHEREVER; git clone git://github.com/evanphx/rubinius.git my_cpp`

+ `cd my_cpp`

+  Switch to the C++ branch:
      `git branch --track cpp origin/cpp; git checkout cpp`
    - The --track allows you to push and pull directly to/from the branch.

+  All of the C++ work is in the vm subdirectory

+  Build the codebase (from toplevel): `rake vm`

+  Build and run the tests (from toplevel): `rake vm:test`

+  You can use `git pull` or `rake git:pull to get updates

+  ...And `git push` or `rake git:push` to send back any of your commits to the
   C++ branch.

 Building the VM
-----------------

  rake vm

 Compiling to .rbc with MRI
----------------------------

MRI can be used to compile Ruby files to bytecode, which can then be run by
the VM. To compile 'file.rb' to 'file.rbc':

  # in the root of the cpp directory
  $ rake compile_ruby[file.rb]


 Running bytecode with the VM
------------------------------

A Ruby file can be run by the VM with the following command:

  # at toplevel
  $ rake run_ruby[file.rb]

Add -t to enable printing of probes in the vm to see various information on
your screen.  Alternately, run the vm by hand:

  $ rake compile_ruby[file.rb]
  $ PROBE=1 vm/vm file.rbc


 Primitives
------------

Primitives are normal methods on C++ classes. Comment annotation links the C++
method to a symbol with which the primitive is accessed in Ruby code.

For example, consider the Ruby Fixnum class:

class Fixnum
  def -@
    Ruby.primitive :fixnum_neg
    raise PrimitiveFailure, "Fixnum#-@ primitive failed"
  end
end

In the C++ file, vm/builtin_fixnum.hpp, the primitive is annotated:

namespace rubinius {

  class Fixnum : public Integer {
    // ...

    // Ruby.primitive :fixnum_neg
    INTEGER neg(STATE) {

The magic for this happens in vm/field_extract.rb and the output goes to
vm/gen/primitives_declare.hpp and vm/gen/primitives_glue.gen.cpp.


 Overloaded C++ Methods as Primitives
--------------------------------------

There are two ways to annotate the C++ methods as primitives. If there is a
single C++ method, use 'Ruby.primitive :name_of_primitive'.

If there are multiple C++ methods (i.e. overloaded methods), use
'Ruby.primitive! :name_of_primitive'. The '!' annotation is used for each
overloaded method and uses the argument types to determine which implementation
method to call for the primitive.

The resulting glue code for overloaded methods looks something like the
following:

bool Primitives::float_mul(STATE, VMExecutable* exec,
                           Task* task, Message& msg) {
  OBJECT ret;
  try {
    if(Float* arg = try_as<Float>(msg.get_argument(0))) {
      return as<Float>(msg.recv)->mul(state, arg);
    }
    if(Integer* arg = try_as<Integer>(msg.get_argument(0))) {
      return as<Float>(msg.recv)->mul(state, arg);
    }
    else {
      throw new Assertion("unable to resolve primitive float_mul types");
    }
  } catch(PrimitiveFailed& e) {
    abort(); // FIXME
    return true;
  }
  task->primitive_return(ret, msg);
  return false;
}


 Tests for Primitives
----------------------

Since the "primitives" are ordinary C++ methods, tests for them are written
along with the other VM tests. Each builtin_xxx.cpp method has a corresponding
vm/test/test_xxx.hpp method. See the existing files for more examples.

