---
mnemonic: create_block
operation: >-
  Creates a compiler1 style block
format: create_block 255
opcode: 87
stack_before:
  - retip
  - blockip
  - blockargs
  - ...
stack_after:
  - blockctxt
  - ...
description: >-
  Pops instruction pointer addresses for where the block should return to
  (_retip_), and the address where the block instructions start (_blockip_) off
  of the stack. Then pops a tuple containing any block arguments off the stack.
  The created block context _blockctxt_ is then pushed back onto the stack.
notes: >-
  The opcode arg is hard-coded at 255 for the current version of create_block.
  This indicates to the VM that the block args are on the stack in a single
  (potentially empty) tuple; previously, the number of block args would be
  specified via this arg, but this is no longer supported. An arg value of
  anything other than 255 will raise an assertion.
  
  create_block is deprecated under compiler2 in favour of create_block2.
source: |-
    next_int;
    t1 = stack_pop();
    t2 = stack_pop();
    if(_int == 255) {
      t5 = stack_pop();
    } else {
      sassert(0 && "old-style block!!");
      t5 = Qnil;
    }
    
    t4 = c->active_context;

    t3 = Qnil;
    if(blokctx_s_block_context_p(state, t4)) {
      t3 = blokctx_home(state, t4);
    } else {
      t3 = t4;
    }
    
    methctx_reference(state, t4);
    methctx_reference(state, t3);
    
    cpu_flush_sp(c);
    cpu_flush_ip(c);
    j = c->ip + BS_JUMP;
    t2 = blokenv_s_under_context(state, t3, t4, j, t1, t2, t5);
    stack_push(t2);
