Stage 0: Input
===========================

The sample input is in test.rb and looks like this:

    def foo()
      puts "foo"
    end

Rubinius extends @File@ with the method @.to_sexp@ which will have
the parser produce us a nested set of Arrays with the necessary info
to be able to interpret (or in our case, compile) the program. How 
the parser works is outside the scope of treatise but this is its 
output, hereafter referred to as the *sexp* (S-expression):

    [:newline, 1, "test.rb", 
      [:defn, :foo, 
        [:scope, 
          [:block, [:args], 
            [:newline, 2, "test.rb", 
              [:fcall, :puts, [:array, [:str, "foo"]]]
            ]
          ], 
          []
        ]
      ]
    ]

If you compare the sexp to the code snippet above, is pretty simple. 
@:defn@ is clearly the method definition, @:scope@ and @:block@ contain
the code within it and that contained code is the @:fcall@. The 
@:newline@s are just that, line information. This all will become
much clearer as we go along.

Next step is to create a new @Compiler@ instance (nothing fancy there)
and get to work translating
