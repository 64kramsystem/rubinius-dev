Stage 2: Bytecode generation
============================

The benefit of having the nested @Node@ structure over the original
sexp may not be immediately obvious, but it is the ability of the
@Node@ objects to have behaviours, unlike the plain sexp. In other
words instead of having an external entity manage it, the @Node@s 
will generate their own code using the knowledge that they have
accumulated. To separate AST generation from bytecode generation,
@Node@s originally from @node.rb@ are reopened in @bytecode.rb@
to add the @#bytecode@ method (and some other stuff.)

A word about that code: this stage is a bit ambiguous. Conceptually
speaking the first step is to generate assembly code of sorts,
essentially something that is still "symbolic code" and not just
a string of ones and zeroes (that would be "machine code".) The
benefit of the former is, of course, that it is easier for humans
to read than the raw bytes. We could technically have the @Node@s 
produce a string of instructions (and in fact that is just what
@TextGenerator@ in @text.rb@ does) and then interpret that string
into the *real* bytecode or machine code but this is a bit wasteful.

Rubinius opts for a sort-of middle ground by first having the @Node@
objects generate a "stream" or sequence of instructions in the form 
of simpler Ruby objects which will then later be encoded into the raw
bytecode format in stage 3.

As you have probably noticed, the Rubinius runtime model is based
on methods. In fact, any script or snippet is essentially a method
in its own right and the basic building blocks in the VM are 
@CompiledMethod@s more on which later and @MethodContext@s which
are beyond the scope of this treatise. For this intermediate 
representation we naturally opt for the same approach. 

@MethodDescription@ will store our important data. The second and
more important player is the @Generator@ class from @generator.rb@
which, despite its name, does not actually so much generate the
code as act as receptacle thereof. In other words, the "syntax,"
if you wish, is in @Generator@ and the logic comes from the @Node@s.

Now.

If you still remember, the last stage ended with the topmost @Node@,
a @Script@ to be specific, was returned from the compiler. This is
fortunate because only @ClosedScope@s implement the @#to_description@
method that allows us to start this phase.

    ast = compiler.into_script ...
    desc = ast.to_description

This will obviously send us into @ClosedScope#to_description@ which
you will find in @bytecode.rb@.
