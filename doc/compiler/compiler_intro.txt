TODO: Break into files in the doc/compiler/ directory.

= Introduction to the Rubinius compiler

This document presents the sequence of transformations that it takes
to compile a very simple Ruby source file into Rubinius bytecode (or,
to be specific, intcode) for the purposes of understanding the basic
operation of the compiler component of the VM. Even source files with
more complex syntax will follow the same general processing pattern.
The compiler is conceptually very straightforward and elegant.

I use a very liberal pseudocode syntax for most of the explanation
just to keep things simple. For any clarifications, you can check the
source. Generally any data structures shown represent what is being
passed to the next step rather than the state in the explanation just
above it: for example in the first stage, the sexp shown is always
essentially the "argument" to the next method or section.

== Stage 0: Input

The sample input is in test.rb and looks like this:

  def foo()
    puts "foo"
  end

Rubinius extends File with the method #to_sexp which will have
the parser produce us a nested set of Arrays with the necessary info
to be able to interpret (or in our case, compile) the program. How
the parser works is outside the scope of treatise but this is its
output, hereafter referred to as the *sexp* (S-expression):

  [:newline, 1, "test.rb",
    [:defn, :foo,
      [:scope,
        [:block, [:args],
          [:newline, 2, "test.rb",
            [:fcall, :puts, [:array, [:str, "foo"]]]
          ]
        ],
        []
      ]
    ]
  ]

If you compare the sexp to the code snippet above, is pretty simple.
+:defn+ is clearly the method definition, +:scope+ and +:block+ contain
the code within it and that contained code is the +:fcall+. The
+:newline+ nodes are just that, line information. This all will become
much clearer as we go along.

Next step is to create a new Compiler instance (nothing fancy there)
and get to work translating

== Stage 1: Sexp to AST

=== 1.1 Descending into the sexp

The sexp is first sent to <tt>Compiler#into_script</tt> (compiler.rb) which
will eventually return some type of a Node object for further processing.
Nodes represent nodes in the resulting AST (Abstract Syntax Tree).

General notes:

* compiler.rb implements the compiler infrastructure as well as the basic
  Node class and its default operations. Subclasses of Node reside in
  nodes.rb and override methods as necessary.
* Node.kind allows node types to register themselves into a mapping of sexp
  node name => node class, this is <tt>Compiler::Node::Mapping</tt>. For
  example, a method definition appears as +:defn+ in the sexp and that is
  mapped to the Define node although usually the names are the same with the
  exception that the node class name is of course capitalised.
* Error handling is present all along the way but I ignore it because
  there is nothing fancy there. Any errors here are unrecoverable.

Compiler#into_script wraps the plain sexp inside a +:script+ and sends
it to Compiler#convert_sexp.

  [:script,
    [:newline, 1, "test.rb",
      [:defn, :foo,
        [:scope,
          [:block, [:args],
            [:newline, 2, "test.rb",
              [:fcall, :puts, [:array, [:str, "foo"]]]
            ]
          ],
          []
        ]
      ]
    ]
  ]

We will run into #convert_sexp pretty much every single step of the way.
It simply looks up the correct node type from the mapping by using the
first element in the sexp that it receives and then calls the #create
method on the class with the sexp and a reference to the compiler.

So <tt>c.convert_sexp sexp</tt> -> <tt>Script.create c, sexp</tt>

  [:script,
    [:newline, 1, "test.rb",
      [:defn, :foo,
        [:scope,
          [:block, [:args],
            [:newline, 2, "test.rb",
              [:fcall, :puts, [:array, [:str, "foo"]]]
            ]
          ],
          []
        ]
      ]
    ]
  ]

None of the Node subclasses implement #create themselves so we are still
in compiler.rb. .create shifts away the now-unnecessary first element of
the sexp and then creates a new instance of the node subclass.

The following step is the main function of this compilation stage. We ask
the Node subclass instance to #consume the remaining sexp which produces
an output. By default #consume will simply recursively process all
nested Arrays (sexps) and leave any non-Array elements alone but this
behaviour is overridden by some subclasses (as we will see shortly) to
make the most important processing happen.

The output is then sent to the #args method of the node instance or,
if the node type needs argument normalisation (to reconcile all variants
of a particular sexp type), to #normalize instead. Neither of these
have a default implementation in Node so look under the specific class
in nodes.rb.

In our case, Script.create c, sexp, we see the first slight modification
in creating the Script instance. Script < ClosedScope, and the purpose of
all ClosedScopes is to represent visibility scopes in the code. The main
part here is that a new LocalScope object is created (you can see locals.rb
but we will get back to this later.)

Next, we step into Script#consume (or ClosedScope#consume to be
specific) with our newly stripped sexp.

  # Script.create c, sexp
  #   Script.new   (creates a new LocalScope)
  #   s.consume sexp
  #   args *result
  [
    [:newline, 1, "test.rb",
      [:defn, :foo,
        [:scope,
          [:block, [:args],
            [:newline, 2, "test.rb",
              [:fcall, :puts, [:array, [:str, "foo"]]]
            ]
          ],
          []
        ]
      ]
    ]
  ]

ClosedScope#consume assumes that it is getting a single-element
Array containing the rest of the sexp for this particular scope (in
our case the entire script.)

It has a couple other important duties too, though: firstly, it
uses the compiler's #set method to set the current scope as itself
as well as the default visibility as public. #set and #get are
the compiler's way to change and describe the current compilation
state and various auxiliary data.

Secondly, the scope will #formalize! all contained scopes. We
will return to this later, but formalization is the process of
reserving stack space and assigning indexes to any local variables
or arguments.

  # Script#consume        (nodes.rb)
  #   super to ClosedScope#consume
  #   out = convert sexp.first (which is a Newline)
  #   formalize all scopes
  [:newline, 1, "test.rb",
    [:defn, :foo,
      [:scope,
        [:block, [:args],
          [:newline, 2, "test.rb",
            [:fcall, :puts, [:array, [:str, "foo"]]]
          ]
        ],
        []
      ]
    ]
  ]

The Node#convert call you see there just calls Compiler#convert_sexp
which, as you recall, is where this whole thing got started. This will be
a recurring pattern.

Through the normal route, we get to Newline.create which in turn
uses default processing to #consume the rest of the sexp (the first
element is again stripped after the node type lookup.)

  # Compiler#convert_sexp -> Newline.create
  #   Newline#consume sexp.shift
  [1, "test.rb",
    [:defn, :foo,
      [:scope,
        [:block, [:args],
          [:newline, 2, "test.rb",
            [:fcall, :puts, [:array, [:str, "foo"]]]
          ]
        ],
        []
      ]
    ]
  ]

Newline#consume first registers the current file and line
information (the first two elements) with the compiler to help
pinpoint compilation errors and then falls back on default
processing from Node#consume.

The process here is simple: loop through the sexp and push
elements to output. All nested sexps are recursively #converted
first.

So here the eventual output to be returned to .create is
just a three-element Array: [1, 'test.rb', <Define node>].

As we can see, the +:defn+ node will need processing so we
move on to that.

  # convert [:defn
  [:defn, :foo,
    [:scope,
      [:block, [:args],
        [:newline, 2, "test.rb",
          [:fcall, :puts, [:array, [:str, "foo"]]]
        ]
      ],
      []
    ]
  ]

(I will start abbreviating some common steps here.)

  # n.convert -> c.convert_sexp -> Define.create
  #   Define.new.consume sexp.shift
  [:foo,
    [:scope,
      [:block, [:args],
        [:newline, 2, "test.rb",
          [:fcall, :puts, [:array, [:str, "foo"]]]
        ]
      ],
      []
    ]
  ]

Define is also a ClosedScope but it will significantly augment
the normal #consume from the latter. First we separate the name
and the body, after which the body gets supered to ClosedScope#consume
wrapped inside a dummy Array. After getting the body back, we will
massage it a bit to suit our needs but this will be done in part 2.
The eventual output here will be [name, <scope>, <args>].

  # Define#consume -> ClosedScope#consume [body] -> convert body.first
  [:scope,
    [:block, [:args],
      [:newline, 2, "test.rb",
        [:fcall, :puts, [:array, [:str, "foo"]]]
      ]
    ],
    []
  ]

Scope nodes do not manage the scopes themselves, they are merely
abstractions within the actual visibility scopes. Scope#consume
assumes it is getting a two-element sexp of which only the first
needs further processing (the second contains local variable names.)

  # n.convert -> c.convert_sexp -> Scope.create -> Scope#consume
  [
    [:block, [:args],
      [:newline, 2, "test.rb",
        [:fcall, :puts, [:array, [:str, "foo"]]]
      ]
    ],
    []
  ]
  
  # Scope#consume
  #   sexp[0] = convert sexp[0]
  [:block,
    [:args],
    [:newline, 2, "test.rb",
      [:fcall, :puts, [:array, [:str, "foo"]]]
    ]
  ]

Block, then, typically encapsulates any type of block of code,
not a lambda block. It is used in method definitions, if-expressions
and so on.

  # c.convert_sexp -> Block.create
  #   Block.new.consume sexp.shift
  [
    [:args],
    [:newline, 2, "test.rb",
      [:fcall, :puts, [:array, [:str, "foo"]]]
    ]
  ]

This is the first time we encounter a sexp with two separate nested
sexps. Both will be processed separately and the output will be just
[<arg node>, <newline node>].

  # Block#consume -> Node#consume
  #   Loop through sexp, recursively convert nested sexps
  #   convert [:args
  [:args]
  #   convert [:newline
  [:newline, 2, "test.rb",
    [:fcall, :puts, [:array, [:str, "foo"]]]
  ]

Stepping through Arguments first.

  # c.convert_sexp -> Arguments.create
  #   Arguments.new.consume sexp.shift
  []

Since we have no arguments, there is no work to be done. However, to
make things consistent, Arguments#consume will return a structure
representing no args of any kind, [[], [], nil, nil] (the fields are
required arg names, optional arg names, splat arg name and default arg
computations. See the source in nodes.rb for more info.)

The second node to process is the newline, one of which we have seen
already. Nothing new here.

  # c.convert_sexp -> Newline.create
  #   Newline.new.consume sexp.shift
  [2, "test.rb",
    [:fcall, :puts, [:array, [:str, "foo"]]]
  ]
  
  # Newline#consume
  #  The line and file are passed to Compiler#set_position
  #  super sexp -> Node#consume sexp
  #    Loop through sexp, recursively convert nested sexps
  #      convert [:fcall
  [:fcall, :puts, [:array, [:str, "foo"]]]

FCall is a bit more interesting. It represents a method call without
an explicit receiver ("functional" style) and it is the first node that
must be #normalized. FCall < Call < MethodCall < Node.

  # c.convert_sexp -> FCall.create
  #   FCall.new
  #     MethodCall does a bit of extra work here by storing
  #     the scope type (it was #set before, if you recall.)
  #     In our case the scope type is Script. We also start
  #     out assuming no block is involved with this call.
  #
  #   f.consume sexp.shift
  [:puts, [:array, [:str, "foo"]]]
  
  # FCall#consume -> Node#consume
  #   Loop through sexp, recursively convert nested sexps
  #   convert [:array
  [[:array, [:str, "foo"]]]
  
  # c.convert_sexp -> ArrayLiteral.create
  #   ArrayLiteral.new.consume sexp.shift
  [[:str, "foo"]]
  
  # ArrayLiteral#consume -> Node#consume
  #   Loop through sexp, recursively convert nested sexps
  #   convert [:str
  [:str, "foo"]
  
  # c.convert_sexp -> StringLiteral.create
  #   StringLiteral.new.consume sexp.shift
  ["foo"]
  
  # StringLiteral#consume -> Node#consume
  #   Loop through sexp, recursively convert nested sexps
  #   (Nothing to do, just "foo" remains.)

At this point, we are at the end of the tree. There is nothing
more to parse and we are ready for the next phase.

=== 1.2 Creating the AST

Now we traverse back up the sexp, pushing the generated Nodes
upwards as we go. As you remember, the second part of each
.create was sending the output of #consume to #args or
#normalize. In the last step, we ended up with StringLiteral
and that is where we will pick up.

The output of a default Node#consume is basically just the original
sexp but with any nested sexps also converted (this may not hold
true for subclasses.) In the case of StringLiteral, there were
no nested expressions, just the actual literal. (<- is used to
denote returning.)

StringLiteral#consume returns ["foo"] and execution picks
back up in Stringliteral.create where the returned value is
passed into StringLiteral#args. All #args does here is
store the string within the StringLiteral node. After this,
StringLiteral.create is done, returning the node object.

The execution then unwinds from StringLiteral.create to
Compiler#convert_sexp to <Node class>#convert and ends up
in the #consume of the parent. In the case of StringLiteral,
we end up in ArrayLiteral#consume.

This sequence will largely be the same for all cases so you will
see it abbreviated like this:

  # StringLiteral#consume
  #   <- StringLiteral.create
  #     StringLiteral#args return
  #       string = 'foo'
  #     <- c.convert_sexp
  #       <- n.convert
  #         <- ArrayLiteral#consume
  
  StringLiteral
  .string = 'foo'

So the StringLiteral goes back to ArrayLiteral#consume
which then sends it to ArrayLiteral#args:

  # ArrayLiteral#consume
  #  <= ArrayLiteral.create
  #   ArrayLiteral#args
  #     body =
  
  ArrayLiteral
  .body = [StringLiteral
           .string = 'foo']
  
  # Return to FCall#consume

FCall#consume yields its process results back to .create
and, because FCall does implement #normalize, the output
is sent there rather than #args. #collapse_args will just
strip away the unnecessary ArrayLiteral and give us an
internal Array containing the ArrayLiteral contents instead.
FCall also checks #detect_special_form to be able to
translate pseudo-calls like +:ivar_as_index+ but we have
none in our little script.

  # FCall#consume
    out = [:puts, anArrayLiteral]
    <- FCall.create
        FCall#normalize
          method, arguments = :puts, al
          collapse_args -> Call#collapse_args
  
  FCall
  .method = :puts
  .arguments = ArrayLiteral
                ...
  
  # collapse_args
  
  FCall
  .method = :puts
  .arguments = [StringLiteral
                .string = 'foo']
  
  # Return to Newline#consume

Nothing special in Newline, the processed nodes just get
stored. Notably we do not even clear the file, line info
that was set earlier.

  # Newline#consume
  #   out = [1, 'test.rb', fc]
  #   <- Newline.create
  #     We do NOT clear the compiler file, line positions
  #     Newline#args
  #     file, line, child = 'test.rb', 1, fc
  
  Newline
  .file = 'test.rb'
  .line = 1
  .child = FCall
           .method = :puts
           .arguments = [StringLiteral
                         .string = 'foo']

There were two forks in Block#consume so we complete the other
one, Arguments, before going further up the chain. We have
no arguments so your basic assignment again. (If we did have
args, Arguments#populate would handle properly associating
the variable names to Local objects.)

  # Arguments#consume
  #   out = [[], [], nil, nil]
  #   <- Arguments#create
  #     Arguments#args
  #       required, optional, splat, defaults = [], [], nil, nil
  #       block_arg = nil   (may be set later)
  #     Skip Arguments#populate
  
  Arguments
  .required = []
  .optional = []
  .splat = nil
  .defaults = nil
  .block_arg = nil

Alright, now we have both trees back and can finish up with
the Block which actually just stores both the args *and*
the body in a single Array.

  # Block#consume
  #   out = [args, nl1]
  #   <- Block.create
  #     Block#args
  
  Block
  .body = [Arguments
           .required = []
           .optional = []
           .splat = nil
           .defaults = nil
           .block_arg = nil
          ,
           Newline
           .file = 'test.rb'
           .line = 1
           .child = FCall
                    .method = :puts
                    .arguments = [StringLiteral
                                  .string = 'foo']
          ]

Back up we go to Scope#consume. As you rememeber, this only
manipulated sexp[0] (which is our Block), so:

  # Scope#consume
  #   out = [Block ..., []]
  #   <- Scope.create
  
  Scope
  .locals = []
  .block = [Arguments
            ...,
            Newline
            ...]
  
           Block
           .body = [Arguments
                    .required = []
                    .optional = []
                    .splat = nil
                    .defaults = nil
                    .block_arg = nil
                   ,
                    Newline
                    .file = 'test.rb'
                    .line = 1
                    .child = FCall
                             .method = :puts
                             .arguments = [StringLiteral
                                           .string = 'foo']
                   ]

Return gets us to to ClosedScope#consume because Define#consume
supered to it for its body part.

ClosedScope#consume is done with its subnodes so it will #formalize!
all scopes. This deals with assigning indexes for local variables, and
possibly reserving stack space when necessary. We have no locals so
we need not worry about it. The Scope from above is returned to
Define#consume.

Define#consume extracts Scope.block.body back out again and then
further splits it into args and the rest. If a block argument is
detected at this point, it gets recorded in the args.

  # Define#consume
  #   out = [:foo, <modified scope>, <args extracted from scope>]
  #   <- Define.create
  #     Define#args
  
  # This...
  
  Scope
  .locals = []
  .block = Block
           .body = [Arguments
                    .required = []
                    .optional = []
                    .splat = nil
                    .defaults = nil
                    .block_arg = nil
                   ,
                    Newline
                    .file = 'test.rb'
                    .line = 1
                    .child = FCall
                             .method = :puts
                             .arguments = [StringLiteral
                                           .string = 'foo']
                   ]
  
  # Becomes this when we extract scope.block.args
  # And add the Define node
  
  Define
  .name = :foo
  .body = Scope
          .block = Block
                   .body = [Newline
                            .file  = 'test.rb'
                            .line  = 2
                            .child = FCall
                                     .method    = :puts
                                     .arguments = [StringLiteral
                                                   .string = 'foo']]
          .locals = []
  .args = Arguments         # args are here now
          .required  = []
          .optional  = []
          .splat     = nil
          .defaults  = nil
          .block_arg = nil


Newline#consume has nothing new to offer, we just store the
positional information.

  # Newline#consume
  #   out = [1, 'foo.rb', meth]
  #   <- Newline.create
  #     Newline#args
  
  Newline
  .file  = 'test.rb'
  .line  = 1
  .child = Define
           .name = :foo
           .body = Scope
                   .block = Block
                            .body = [Newline
                                     .file  = 'test.rb'
                                     .line  = 2
                                     .child = FCall
                                              .method    = :puts
                                              .arguments = [StringLiteral
                                                            .string = 'foo']]
                   .locals = []
           .args = Arguments
                   .required  = []
                   .optional  = []
                   .splat     = nil
                   .defaults  = nil
                   .block_arg = nil

Finally, we are back in Script#consume. Being a ClosedScope,
it will also #formalize! its locals (and we still have none.)

Curiously, the "body" of the script is just the single newline
but this is just because the top-level is only really concerned
about the code it directly contains. If our original code had been:

  def foo
    puts "foo"
  end
  
  foo

Then the Script would have ended up with its body a Block
that in turn contained two Newline objects (with line numbers
1 and 5 respectively.)

Anyway, for now Script#args just stores the body.

That is it for the compilation phase! This is the complete
resulting structure for our tiny program:

  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           .block = Block
                                    .body = [Newline
                                             .file  = 'test.rb'
                                             .line  = 2
                                             .child = FCall
                                                      .method    = :puts
                                                      .arguments = [StringLiteral
                                                                    .string = 'foo']]
                           .locals = []
                   .args = Arguments
                           .required  = []
                           .optional  = []
                           .splat     = nil
                           .defaults  = nil
                           .block_arg = nil

Now we return to Compiler#into_script.

== Stage 2: Bytecode generation

The benefit of having the nested Node structure over the original
sexp may not be immediately obvious, but it is the ability of the
Node objects to have behaviours, unlike the plain sexp. In other
words instead of having an external entity manage it, the Nodes
will generate their own code using the knowledge that they have
accumulated. To separate AST generation from bytecode generation,
Nodes originally from node.rb are reopened in bytecode.rb
to add the #bytecode method (and some other stuff.) The VM
works off a stack so the generated bytecode will be stack-based.

A word about that code: this stage is a bit ambiguous. Conceptually
speaking the first step is to generate assembly code of sorts,
essentially something that is still "symbolic code" and not just
a string of ones and zeroes (that would be "machine code".) The
benefit of the former is, of course, that it is easier for humans
to read than the raw bytes. We could technically have the Nodes
produce a string of instructions (and in fact that is just what
TextGenerator in text.rb does) and then interpret that string
into the *real* bytecode or machine code but this is a bit wasteful.

Rubinius opts for a sort-of middle ground by first having the Node
objects generate a "stream" or sequence of instructions in the form
of simpler Ruby objects which will then later be encoded into the raw
bytecode format in stage 3.

As you have probably noticed, the Rubinius runtime model is based
on methods. In fact, any script or snippet is essentially a method
in its own right and the basic building blocks in the VM are
CompiledMethods more on which later and MethodContexts which
are beyond the scope of this treatise. For this intermediate
representation we naturally opt for the same approach.

MethodDescription will store our important data. The second and
more important player is the Generator class from generator.rb
which, despite its name, does not actually so much generate the
code as act as receptacle thereof. In other words, the "syntax,"
if you wish, is in Generator and the logic comes from the Nodes.
The Encoder will also make an appearance, although its main
function is not explored until the next stage.

A note about the pseudocode used in the description here: The
generated code will be in a sort-of-assembly syntax and I will
use assembly comments ; for any comments that could be imagined
to be left there by the "writer." Ruby comments # are used
for "meta-information." I will also introduce new pseudocode
elements as they are needed so as to not confuse matters up
front and will always explain when I do so. Hopefully this will
help rather than hinder clarity.

Now.

If you still remember, the last stage ended with the topmost Node,
a Script to be specific, was returned from the compiler. This is
fortunate because only ClosedScopes implement the #to_description
method that allows us to start this phase.

  # Eventually, the topmost MethodDescription is returned.
  ast = compiler.into_script ...
  desc = ast.to_description

This will obviously send us into ClosedScope#to_description which
you will find in bytecode.rb.

This is a bit of a tangled web. We start with three players: the
Script (which we will start calling $script) sets up a new MethodDescription
which also provides a Generator ( <--- SUBJECT TO CHANGE ) which is
exposed to $script. Then, $script asks the MethodDescription to
run using $script as its argument. This, in turn will cause the
Generator ($gen) to run again using $script as its starting
point and as before, starts its descent from here. Eventually after
this the MethodDescription gathers #argument_info from the Node
and returns. Because $script is sort of a pseudomethod, it will
only have dummy values here. For now, let us proceed though.

  desc.run $script -> $gen.run $script

Generator#run is an exceedingly simple matter: it merely requests
the Node given to it to execute its #bytecode method, passing
itself as a parameter in order to continue down the tree. So in
our case, we head into Script#bytecode.

The #bytecode methods are the backbone of this entire operation,
as mentioned earlier. Each Node will know the logic required to
compile itself and this logic collected by the #bytecode methods
calling various methods on the Generator object they are passed.
The Generator, then, records those operations into its internal
instruction stream.

Script#bytecode starts by generating a prelude (compiler term for
work that is done to set up a method before code inside it starts
executing) which simply reserves space for local variables within
this scope. The space required has been determined in the earlier
calls to ClosedScope#formalize! which was a part of the cycle
for ClosedScope#consume. Since there were no locals at the toplevel,
the size we need is 0.

To actually achieve this, we call $gen.allocate_stack which in
turn just calls Generator#add with the argument pair +:allocate_stack+, 0
This is, essentially, the "assembly code."

Generator#add handles incrementing its instruction pointer to
account for the new code in the stream (the ip always points to
the last element in the stream) and then looks up the actual numeric
opcode of our "assembly" instruction +:allocate_stack+. It happens
to currently be 97 but may change at any time so for clarity
our pseudocode will not refer to it at all, it is just extra
info kept in the stream by the Generator itself.

For our code, the instruction pointer (ip) is not that important
but it is very much so when dealing with branching. After you are
done with this, see (TODO: link to text about labels) for more info.

The prelude done, $script wants to have its body processed before
proceeding with the rest of its code so that the instruction stream
is in the correct order.

  # $script.bytecode
  #   $gen.allocate_stack 0
  #     $gen.add :allocate_stack, 0
  #       Increment instruction pointer, look up opcode
  #   $script.body.bytecode
  
  # "Assembly" stream
  ; No allocation needed
  
  # We are starting back up here
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   ...

The body itself is a Newline node and the first thing one of
those wants to do is to let the Generator know its line and
file information. Generator#set_line actually does a bit more
work because for all the lines in the code, it keeps track of
the starting and ending instruction pointers (or in other words,
stream positions.) Importantly, this information is not recorded
in the instruction stream and is just kept track of by $gen.
(These helper methods are collectively referred to as "commands"
whereas the ones that actually affect the stream are "operations.")

Since we just started, line 1 of the real code starts at $gen.ip == 2
and ends.. well, we do not know yet. The file is also stored but
since Ruby code is always compiled in units of one file, there is
nothing fancy to do there.

The only other thing for a Newline to do is to send the code
it contains to be processed.

  # Nothing new in the stream
  ; No allocation needed
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           ...
                   .args = Arguments
                           ...

The next step is quite interesting. As you remember, we are technically
inside a MethodDescription object--so what happens when we need to
describe another method? There are some important concepts to cover.

Define#bytecode starts off with $gen.push_literal compile_body().
Define#compile_body actually produces a new MethodDescription --
to which we will get in a moment -- so the "literal" is not one in the
sense of a string literal or an array literal. What actually happens
here is that the object given to #push_literal is stored with other
literals in $gen and its index within that group is used for the
actual "assembly". The actual literal objects will eventually get
stored in the CompiledMethod object (if we are compiling to a file,
then even further along they will be marshalled along with the rest
of the CompiledMethod.)

Again, in the interest of maintaining the correct sequence, the code
that makes up the method body will get generated first. Exploring
Define#compile_body shows a very similar process to what got us
started with $script. We set up a new MethodDescription which
means that for the time being we will be working with a different
Generator. A new prelude is produced but since we still have no
local variables, a 0 stack allocation is needed.

In the pseudocode, in order to distinguish the Generators, the
original will be $gen and the one for foo is $subgen whenever
needed. For fun, I will also indent foo.

Next, in this order, we generate the argument handling code and then
the method body.

  # Toplevel
  ; No allocation needed
  
  # foo
    ; No allocation needed
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           ...
                   .args = Arguments
                           .required  = []
                           .optional  = []
                           .splat     = nil
                           .defaults  = nil
                           .block_arg = nil

The processing of Arguments is a bit more involved than our
previous Nodes (or would be if #foo took any.) Even in our
case, though, the argument count needs to be checked so we
figure out how many are needed (0) and how many can be given
(also 0.) Interestingly, the maximum possible number of arguments
is currently 1024. First, back to Define and then down the
other fork to its body.

  # Toplevel
  ; No allocation needed
  
  # foo
    ; Argument handling
    check_argcount 0 0    ; ip == 3
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           .block = Block
                                    ...
                           .locals = []
  
                   .args = Arguments
                           ...

Define wants to generate the code for its body so Scope#bytecode
is our next destination but all there is to do is to further descend
in and ask for Block#bytecode from the block contained (nope, we
are STILL not touching the locals.) Block in our case also ends up
just asking its body for its #bytecodes since we only have one
element in it.

  # Toplevel
  ; No allocation needed
  
  # foo
    ; Argument handling
    check_argcount 0 0    ; ip == 3
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           .block = Block
                                    .body = [Newline
                                             .file  = 'test.rb'
                                             .line  = 2
                                             .child = FCall
                                                      ...
                           .locals = []
  
                   .args = Arguments
                           ...

Another Newline! We started one earlier but since that one resides
in $gen, opening a new one here really does not have any effect on
it. Line 2 starts at ip 3 which gives us the interesting property that
ips 0-2 really do not live anywhere. Next, processing goes to the child
of the Newline.

  # Toplevel
  ; No allocation needed
  
  # foo
    ; Argument handling
    check_argcount 0 0    ; ip == 3
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           .block = Block
                                    .body = [Newline
                                             .file  = 'test.rb'
                                             .line  = 2
                                             .child = FCall
                                                      .method    = :puts
                                                      .arguments = [StringLiteral
                                                                    .string = 'foo']]
                           .locals = []
                   .args = Arguments

The main bytecode generation for all call types happens not in the top
class of that hierarchy, MethodCall, but in Call#bytecode. So also
for our FCall. First order of business is to check whether a plugin
can handle this node (TODO: separate doc about the plugin arch) and in
this case, the answer is "no" so we proceed. Next, arguments for the
call through #emit_args: we do have args and the args are held in
an Array so each of those gets generated -- in reverse order -- and
the argument count is stored. This means a short side trip to
StringLiteral#bytecode which just uses $subgen.push_literal on its
string and then calls $subgen.string_dup which will just cause a new
duplicate string to replace the original on the stack when run (here
is a bit of Generator magic: any operation that is not explicitly
defined just gets #added using #method_missing.) #push_literal,
as you recall, either stores or retrieves an already-stored literal
and gives back its index. A peek at what we look like before heading
back to FCall#emit_args.

(Another pseudocode convention: #<literal> means the index of the
literal from #find_literal.)

  # Toplevel
  ; No allocation needed
  
  # foo
    ; Argument handling
    check_argcount 0 0      ; ip == 3
  
    ; FCall arguments
    push_literal #<"foo">   ; ip == 5
    string_dup              ; ip == 6

Nothing further to do in #emit_args but to store the arg count
and then we drop down to FCall#bytecode again. There are checks
for block code generation as well as dynamic arguments (these are
+:splats+, +:argscats+ and +:argspushes+) neither of which affects
us. Next code to generate would be for the receiver (the receiver
could for example itself be a result of a method call) but we are
again lucky because an FCall by definition has no receiver so
all calls will be to self. This work is all put together in
the $subgen.send operation, which in our case will start by setting
the call flags to allow for private methods (which MUST be called
without an explicit receiver*.)  Further, the method name we want
is looked up or stored in literals and its index retrieved. We
also encounter a small optimisation here: normally, the next
instruction would be +:send_stack+, but because we have <5 args,
1 to be precise, a special instruction +:meta_send_stack_1+ is
used instead. This is what we have when we head back towards
the top again:

  # Toplevel
  ; No allocation needed
  
  # foo
    ; Argument handling
    check_argcount 0 0          ; ip == 3
  
    ; FCall arguments
    push_literal #<"foo">       ; ip == 5
    string_dup                  ; ip == 6
  
    ; FCall receiver
    push_self                   ; ip == 7
  
    ; FCall send
    set_call_flags 1            ; ip == 9
    meta_send_stack_1 :puts     ; ip == 11
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   .name = :foo
                   .body = Scope
                           .block = Block
                                    .body = [Newline
                                             ...
                           .locals = []
                   .args = Arguments
                           .required  = []
                           .optional  = []
                           .splat     = nil
                           .defaults  = nil
                           .block_arg = nil

Nothing further to do in Newline#bytecode, Block#bytecode is done
as is Scope#bytecode so we finally just end up in Define#compile_body
which we need to finish up. Two small things to do, $subgen.sret will
emit code necessary to return from the method and $subgen.close is a
command to finalise any open lines so now we know that line 2 started
at ip 3 and ended at ip 12.

  # Toplevel
  ; No allocation needed
  
  # foo
    ; Argument handling
    check_argcount 0 0          ; ip == 3
  
    ; FCall arguments
    push_literal #<"foo">       ; ip == 5
    string_dup                  ; ip == 6
  
    ; FCall receiver
    push_self                   ; ip == 7
  
    ; FCall send
    set_call_flags 1            ; ip == 9
    meta_send_stack_1 :puts     ; ip == 11
  
    ; Cleanup
    sret                        ; ip == 12

Code generation responsibility shifts again to the original MethodDescription
and its $gen.

#compile_body actually returns the new MethodDescription we have
been working with so we can finally store the literal and then have
the newly generated method added to self which in our case is the
top-level entity. Notably, the +:add_method+ operation handles looking
up its argument (the name) in literals before generating the real
instruction so it is not necessary to do that part.

  # Toplevel
  ; Add method
  push_literal #<foo>       ; ip == 2
  push_self                 ; ip == 3
  add_method :foo           ; ip == 5
  
  # foo
    ; Argument handling
    check_argcount 0 0          ; ip == 3
  
    ; FCall arguments
    push_literal #<"foo">       ; ip == 5
    string_dup                  ; ip == 6
  
    ; FCall receiver
    push_self                   ; ip == 7
  
    ; FCall send
    set_call_flags 1            ; ip == 9
    meta_send_stack_1 :puts     ; ip == 11
  
    ; Cleanup
    sret                        ; ip == 12
  
  Script
  .body = Newline
          .file  = 'test.rb'
          .line  = 1
          .child = Define
                   ...

Nothing to do in the next Newline either so eventually we just end
up at the very topmost Script#bytecode which merely #pops whatever
the return value of the method definition is (since there is no use
for it and it cannot be left to litter the stack), #pushes true
as its own "return value" and returns.

  # Toplevel
  ; Add method
  push_literal #<foo>       ; ip == 2
  push_self                 ; ip == 3
  add_method #<:foo>        ; ip == 5
  
  ; Cleanup
  pop                       ; ip == 6
  push_true                 ; ip == 7
  sret                      ; ip == 8
  
  # foo
    ; Argument handling
    check_argcount 0 0          ; ip == 3
  
    ; FCall arguments
    push_literal #<"foo">       ; ip == 5
    string_dup                  ; ip == 6
  
    ; FCall receiver
    push_self                   ; ip == 7
  
    ; FCall send
    set_call_flags 1            ; ip == 9
    meta_send_stack_1 :puts     ; ip == 11
  
    ; Cleanup
    sret                        ; ip == 12

Execution takes us back to the first MethodDescription#run which has
one last thing to do: #$gen.close. We now know that line 1 ends at
$gen ip == 8 (and started at ip 2.) At this point, we return to caller.
Now we can actually create the CompiledMethod.

If you want to know what the instructions above do, you can look at the
{opcode docs}[http://rubini.us/doc/vm].

  desc = ast.to_description
  compiled = desc.to_cmethod   # -> $gen.to_cmethod desc

== Stage 3: Encoding and CompiledMethod

One clarification: Rubinius does not actually use BYTEcode in the sense of
one-byte-wide opcodes so it is used here in its banal meaning of virtual
machine machine code. Rubinius' machine code is in fact INTcode. encoder.rb
will be the main venue here (although, again, {the VM
docs}[http://rubini.us/doc/vm] are an excellent resource for anything to do
with Rubinius bytecode.)

The process of creating a CompiledMethod starts from Generator#to_cmethod
to which we get through MethodDescription#to_cmethod. The first thing that
happens is that the Generator goes through its entire stream, "collapsing"
any Labels it encounters. You can review (TODO: link to label text) for
more info but suffice to say Labels are just positions is the stream that
can be used for branching, gotos and jumps. Our code has no Labels so we
need not worry about it. The first thing we need to do is have the Encoder
convert our "assembly code" into an InstructionSequence.

If you look at encoder.rb, it is almost deceptively simple. At the top there
are several data structures to help us keep track of the various opcodes and
any special properties they may have. Towards the bottom, there is only a
little tiny bit of code that is supposed to handle everything for us.

We start off with Encoder#encode_stream, expecting back an InstructionSequence.
#encode_stream first calculates the size required for the iseq and then creates
one. Then it simply #encodes each operation in the stream, keeping track of
the offset into the InstructionSequence.

#encode is not a very complicated method, either: the numeric opcode is
looked up and then its "width" or number of additional arguments is
determined from the lookup tables at the top of encoder.rb. For each
one of these elements (maximum three, opcode + 0, 1 or 2 arguments) gets
encoded into the InstructionSequence using Encoder#int2str.

#int2str just writes the given number into the iseq as a big-endian 4-byte
integer split into 4 byte-sized segments. For example, 17 would end up as
[0, 0, 0, 17] whereas 256 becomes [0, 0, 1, 0] and so on. The fully
encoded InstructionSequence is then returned to Generator#to_cmethod.

Next we create the CompiledMethod object (which, by the way, is immensely
cool, do var = def my_method ... in sirb and see what all you can do
with var! Also see TODO: Rubinius reflection capabilities) using the
InstructionSequence just created. The CM is not quite ready yet, though,
so we store its name, the file it was defined in (these are either real
names or one of the special names such as +:__eval__+ or +:__unknown__+) as
well as the serial which is essentially a version number.

Before you think I forgot about foo, that comes next as #to_cmethod
goes through #encode_literals, #encode_lines and #encode_exceptions
(as you rememeber, the MethodDescription for foo was stored as a literal.)

All three of those are very similar and do not really perform any actual
encoding like we saw before. Each just goes through its ascribed list
and stores the objects in a Tuple (a very primitive fixed-size container)
and the only exception to this is #encode_literals and then only for
any MethodDescriptions it finds. For those it calls lit.to_cmethod
which obviously then recursively generates the CompiledMethods. The
generated ones get stored in the literals tuple in place of the old
MethodDescription.

And that is all there is to it. The CompiledMethod is finished and
it can be stashed away somewhere (a MethodTable, for example), it
can be #activated to have the code run and so on. If you are interested
in what happens when one IS activated, read TODO: link to execution.

Well, maybe there is one little thing that might deserve to be
covered still: how can CompiledMethods be stored on disk in .rbc
files?

== Stage 4: Bytecode on disk.

The loading and unloading of code -- CompiledMethods -- to disk
happens through Marshal and is mostly defined in shotgun/lib/cpu_marshal.c.

The entire thing, from a high level, is fairly trivial. cpu_marshal() first
brands the file with the special string "RBIX" followed by a version number
to be able to detect the formatting required (when loading back again.) From
there, cpu_marshal_cmethod2() takes care of the rest. The basic idea for
marshalling is simple although it varies slightly from one object to another:
first a type identifier is printed ("M" for a CompiledMethod) possibly
followed by some type of version identifier or a size (a string, for
example, will write the number of characters) that will allow unmarshalling
the object later. After this comes the object data.

cpu_marshal_cmethod2() loops through the 16 fields of a CompiledMethod
and recursively marshals them. For example, the name (field 5) is a Symbol
which uses the format 'x' + size + characters so for our method from
above, the end-result would be, in hex:

  78 00 00 00 03 66 6f 6f
   x           3  f  o  o

Unmarshalling back into a CompiledMethod is a very similar process.
All that happens is that a new, blank CompiledMethod is allocated
and then its fields are unmarshalled using a similar process. The
end-result is a finished CompiledMethod.

Easy, right? The implementation, of course, is a bit more involved
(mostly because of working with files) but from our perspective it
is child's play. Do rememeber, though, that this marshal format is
*not* compatible with MRI, not even for the parts that exist in
both implementations such as Strings.

