1. Files and Directories

* .load_order.txt explains the dependencies between files so the VM can load
  them in the correct order.
* kernel/ contains the ruby language additions to the basic VM.  These files
  are compiled into runtime/
* kernel/bootstrap/ contains the files needed to start up Ruby.
* kernel/core/ contains the rest of the Ruby language.
* runtime/ contains run-time compiled files for Rubinius.  You'll use these
  files when running shotgun/rubinius
* runtime/stable/* is only used by commands run from the Rakefile.  You
  probably don't need to touch anything in here, but when you do, you can
  rebuild it with rake build:stable.
* shotgun/ contains the Rubinius VM.
* shotgun/external_libs/ contains libraries required by Rubinius for
  convenience.
* spec/ and test/ contain tests for verifying that Rubinius implements Ruby.

2. Kernel Classes

If you create a new file in one of the kernel subdirectories, it will be
necessary to regenerate the .load_order.txt file in the equivalent runtime
subdirectory in order to get your class loaded when Rubinius starts up. Use the
rake task build:load_order to regenerate the .load_order.txt files.

3. Primitives

To add a primitive:

* Give the primitive a sane name
* Implement the primitive in shotgun/lib/primitives.rb
* Give the primitive a number in shotgun/lib/primitive_names.rb
* `rake runtime/stable/compiler.rba`
* `rake`

If your primitive takes variable arguments, you need to provide a wrapper
method that calls the primitive.  For example Dir::glob calls
Dir::prim_glob.

4. gdb

You can run shotgun/rubinius with gdb.

* Run `shotgun/rubinius --gdb`
* Hit ^C to interrupt
* Type 'rbt' at the gdb prompt to get a ruby backtrace

Useful gdb commands:

* p _inspect(OBJECT)

5. Specifications

RSpec is the machinery behind executing these specs. The intention is to have
specs for Ruby as a language and set of standard libraries, and to TDD/BDD the
development of Rubinius. Some spec subdirectories below are implementation
agnostic and some are specific to Rubinius.

For more information on the Ruby specs developed for Rubinius, see:
http://rubinius.lighthouseapp.com/projects/5089/specs-overview

6. Build w/o Optimization

When you get <value temporarily unavailable, due to optimizations> in gdb, you
can easily rebuild without optimization:

* `touch thefile.c`
* `DEV=1 rake`

To rebuild everything without optimization:

* `rake clean:shotgun`
* `DEV=1 rake`

7. Using C libraries

Module#attach_function allows a C function to be called from Ruby code using
FFI.

Module#attach_function takes the C function name, the ruby module function to
bind it to, the C argument types, and the C return type.

For a list of C argument types, see kernel/platform/ffi.rb.

When the C function will be filling in a String, be sure the Ruby String is
large enough.  For the C function rbx_Digest_MD5_Finish, the digest string is
allocated with a 16 character length.  The string is passed to md5_finish which
calls rbx_Digest_MD5_Finish which fills in the string with the digest.

  class Digest::MD5
    attach_function nil, 'rbx_Digest_MD5_Finish', :md5_finish,
                    [:pointer, :string], :void
  
    def finish
      digest = ' ' * 16
      self.class.md5_finish @context, digest
      digest
    end
  end

For a complete additional example, see digest/md5.rb.

