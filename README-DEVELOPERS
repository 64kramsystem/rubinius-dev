# vim: tw=65

General help and instructions on writing code for Rubinius.


0. Further Reading
==================
At some point, you should read everything in doc/. It is not
necessary to understand or memorise everything but it will
help with the big picture at least!


1. Files and Directories
========================
Get to know your way around the place!

* .load_order.txt
  Explains the dependencies between files so the VM can load them
  in the correct order.

* kernel/
  The Ruby half of the implementation. The classes, methods etc.
  that make up the Ruby language environment are defined here.
  Further divided into..

* kernel/bootstrap/
  Minimal set of incomplete core classes that is used to load up
  the rest of the system. Any code that requires Rubinius' special
  abilities needs to be here too.

* kernel/core/
  Complete implementation of the core classes. Builds on and/or
  overrides bootstrap/. Theoretically this code should be portable
  so all Rubinius-dependent stuff such as primitives goes in
  bootstrap/ also.

* runtime/
  Contains run-time compiled files for Rubinius. You'll use these
  files when running shotgun/rubinius

* runtime/stable/*
  Known-good versions of the Ruby libraries that are used by the
  compiler to make sure you can recompile in case you break one
  of the core classes.

* shotgun/
  The C parts. This top-level directory contains most of the build
  process configuration as well as the very short main.c.

* shotgun/lib/
  All of the C code that implements the VM as well as the extremely
  bare-bones versions of some Ruby constructs.

* shotgun/external_libs/
  Libraries required by Rubinius, bundled for convenience.

* lib/
  All Ruby Stdlib libraries that are verified to work as well as
  any Rubinius-specific standard libraries. Of special interest
  here are four subdirectories:

* lib/bin/
  Some utility programs such as lib/bin/compile.rb which is used
  to compile files during the build process.

* lib/ext/
  C extensions that use Subtend.

* lib/compiler{1,2}/
  These two hold the current and the new compilers, respectively.

* stdlib/
  This is the Ruby Stdlib, copied straight from the distribution.
  These libraries do not yet work on Rubinius (or have not been
  tried.) When a library is verified to work, it is copied to
  lib/ instead.

* bin/
  Various utility programs like bin/mspec and bin/ci.

* spec/ and test/
  These contain the behaviour specification and verification files.
  Rubinius is developed in the Behaviour-Driven Design (BDD) style
  which means we write the specification of how the code should work
  first and then the implementation to comply to that. The specs go
  here. The test/ directory is not used for new specs and has mostly
  inherited tests and benchmarks.


Notes: Occasionally working with kernel/ you may seem classes that
       are not completely defined or looks strange. Remember that
       some classes are set up in the VM and we are basically just
       reopening those classes.


2. Working with Kernel classes
==============================

Any time you make a change here -- or anywhere else for that
matter -- make sure you do a full rebuild to pick up the changes,
then run the related specs, and then run bin/ci to make sure
that also the *unrelated* specs still work (minimal-seeming
changes may have broad consequences.)

There are a few special forms that are used in bootstrap/ as well
as core/, such as @ivar_as_index@ which maps instance variable
names on internal fields. These may impose special restrictions
on their usage so it is best to follow the example of existing
code when dealing with these. Broadly speaking, if something looks
"unrubyish", there is probably a good reason for it so make sure
to ask before doing any "cosmetic" changes -- and to run CI after.

If you modify a kernel class, you need to `rake build` after to
have the changes picked up. With some exceptions, you should not
regenerate the stable files. They will in most cases work just fine
even without the newest code. `rake build:stable` is the command
for that.

If you create a new file in one of the kernel subdirectories, it
will be necessary to regenerate the .load_order.txt file in the
equivalent runtime subdirectory in order to get your class loaded
when Rubinius starts up. Use the rake task build:load_order to
regenerate the .load_order.txt files.

Due to the dependencies inherent in writing the Core in Ruby, there
is one idiom used that may confuse on first sight. Many methods are
called #some_method_cv and the _cv stands for 'core version,' not
one of the other things you thought it might be. The idea is that
a simple version of a given method is used until everything is
safely loaded, at which point it is replaced by the real version.
This happens in WhateverClass.after_loaded (and it is NOT automated.)


2.1 Safe Math Compiler Plugin =============================

Since the core libraries are built of the same blocks as any other
Ruby code, and since Ruby is a dynamic language with open classes and
late binding, it is possible to change fundamental classes, like
Fixnum, in ways that violate the semantics that other classes depend
on. For example, imagine we did the following

class Fixnum
  def +(other)
    (self + other) % 5
  end
end

While it is certainly possible to redefine fixed point arithmetic plus
to be modulo 5, doing so will certainly cause some class like Array to
be unable to calculate the correct length for certain operations.
While the dynamic nature of Ruby is one of its cherished features, it
is truly a double-edged sword.

The mathn library is one that redefines Fixnum#/ in a fundamentally
incompatible manner. The mathn library aliases Fixnum#/ to Fixnum#quo,
which returns a Float by default. Because of this, there is a special
compiler plugin that emits a different method name when it encounters
the #/ method. The compiler emits #divide instead of #/. The numeric
classes Fixnum, Bignum, Float, and Numeric all define this method.
During compilation of the core libraries, the -frbx-safe-math switch
is used to enable this compiler plugin. During regular compilation,
this plugin is not enabled. This enables us to support mathn without
breaking the core libraries.

2.2 ivar_as_index ============================================

As described above, you'll see calls to ivar_as_index in the kernel.
This maps the objects numbered fields to ivar names, but ONLY for
that file.

You can NOT access those names using the @name syntax outside of that file.
Doing so will cause madeningly odd behavior.

For instance, if you make a subclass of IO, you can NOT access @descriptor
directly in your subclass. You must go through methods to access it only.

This is a gotcha of working in the kernel, so be aware of it.

2.3 kernel and user land =====================================

In many ways, rubinius is architected like a normal OS, so i'll use terms
from the OS world to describe the 2 modes of rubinius.

Kernel land is describes how code in kernel/ is executed. Everything else
is user land.

Kernel land has a number of restrictions to keep things sane and simple:

*) No 0 arg versions of: public, private, protected, module_function
*) Limited usage of code in script and class body. Use after_loaded hooks
   for doing fixups or extended computation. The code in platform bends this
   rule the most, but it does not break it.
*) Kernel land code does not use Module#__add_method__ and MetaClass#attach_method.
   It adds and attaches methods directly in the VM. This is necessary for
   bootstrapping.
*) Any use of string-based eval in the kernel must get go through discussion.


3. Libraries and C: Primitives vs. FFI
======================================

There are two ways to "drop to C" in Rubinius. Firstly, primitives
are special instructions that are specifically defined in the VM.
In general they are operations that are impossible to do in the
Ruby layer such as opening a file. Primitives should be used to
access the functionality of the VM from inside Ruby.

FFI or Foreign Function Interface, on the other hand, is meant as
a generalised method of accessing system libraries. FFI is able to
automatically generate the bridge code needed to call out to some
library and get the result back into Ruby. FFI functions at runtime
as real machine code generation so that it is not necessary to have
anything compiled beforehand. FFI should be used to access the code
outside of Rubinius, whether it is system libraries or some type of
extension code, for example.

There is also a specific Rubinius extension layer called Subtend.
It emulates the extension interface of Ruby to allow old Ruby
extensions to work with Rubinius.


4. Primitives
=============
Using the above rationale, if you need to implement a primitive:

* Give the primitive a sane name
* Implement the primitive in shotgun/lib/primitives.rb using the
  name you chose as the method name.
* Enter the primitive name as a symbol at the BOTTOM of the Array
  in shotgun/lib/primitive_names.rb.
* `rake build`

This makes your primitive available in the Ruby layer using the
special form @Ruby.primitive :primitive_name@. Primitives have a
few rules and chief among them is that a primitive must be the
first instruction in the method that it appears in. Partially for
this reason all primitives should reside in a wrapper method in
bootstrap/ (the other part is that core/ should be implementation
independent and primitives are not.)

In addition to this, primitives have another property that may
seem unintuitive: anything that appears below the primitive form
in the method is executed if the primitive FAILS and only if it
fails. There is no exception handling syntax involved. So this
is a typical pattern:

    # kernel/bootstrap/whatever.rb
    def self.prim_primitive_name()
      Ruby.primitive :primitive_name
      raise SomeError, "Whatever I was doing just failed."
    end

    # kernel/core/whatever.rb
    def self.primitive_name()
      self.prim_primitive_name
      ...
    end

To have a primitive fail, the primitive body (in primitives.rb)
should return FALSE; this will cause the code following the
Ruby.primitive line to be run. This provides a fallback so that
the operation can be retried in Ruby.

If a primitive cannot be retried in Ruby, it may raise an
exception using a couple of macros:
* RAISE(exc_class, msg) will raise an exception of type exc_class
  and with a message of msg, e.g.
    RAISE("ArgumentError", "Invalid argument");
* RAISE_FROM_ERRNO(msg) will raise an Errno exception with the
  specified msg.

5. GDB, valgrind
================
To really be able to use GDB, make sure that you build Rubinius
with DEV=1 set. This disables optimisations and adds debugging
symbols.

There are two ways to access GDB for Rubinius. You can, of course,
simply run shotgun/rubinius with gdb (use the builtin support so
you do not need to worry about linking etc.):

* Run `shotgun/rubinius --gdb`
* Hit ^C to interrupt
* Type 'rbt' at the gdb prompt to get a ruby backtrace

You can also drop into GDB from Ruby code by using Kernel#yield_gdb.
To continue past the yield_gdb, jump one line after the line you
have stopped on.

Useful gdb commands:

* rbt
  Prints the backtrace of the Ruby side of things. Use this in
  conjunction with gdb's own bt which shows the C backtrace.

* p _inspect(OBJECT)
  Useful information about a given Ruby object.

Valgrind is a program for debugging, profiling and memory-checking
programs. The invocation is just  `shotgun/rubinius --valgrind`.
See http://valgrind.org for usage information.


6. Specs (Specifications)
=========================
RSpec is the machinery behind executing these specs. The intention
is to have specs for Ruby as a language plus as a set of standard
libraries, and to TDD/BDD the development of Rubinius.

The specs under spec/ruby/* are for the Ruby language, core and
standard libraries.

The rest of the specs under spec/* are for Rubinius. These include
specs for Rubinius extensions to the Ruby core library and specs for
the components of Rubinius itself.

For more information on the Ruby specs developed for Rubinius, see:
http://rubinius.lighthouseapp.com/projects/5089/specs-overview


7. FFI
======
Module#attach_function allows a C function to be called from Ruby
code using FFI.

Module#attach_function takes the C function name, the ruby module
function to bind it to, the C argument types, and the C return type.
For a list of C argument types, see kernel/platform/ffi.rb.

Currently, FFI does not support C functions with more than 6
arguments.

When the C function will be filling in a String, be sure the Ruby
String is large enough. For the C function rbx_Digest_MD5_Finish,
the digest string is allocated with a 16 character length.  The
string is passed to md5_finish which calls rbx_Digest_MD5_Finish
which fills in the string with the digest.

  class Digest::MD5
    attach_function nil, 'rbx_Digest_MD5_Finish', :md5_finish,
                    [:pointer, :string], :void

    def finish
      digest = ' ' * 16
      self.class.md5_finish @context, digest
      digest
    end
  end

For a complete additional example, see digest/md5.rb.
